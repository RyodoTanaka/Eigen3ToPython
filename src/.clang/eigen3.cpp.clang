/* This file was generated by PyBindGen 0.16.0 */
#define PY_SSIZE_T_CLEAN
#include <Python.h>
#include <stddef.h>


#if PY_VERSION_HEX < 0x020400F0

#define PyEval_ThreadsInitialized() 1

#define Py_CLEAR(op)				\
        do {                            	\
                if (op) {			\
                        PyObject *tmp = (PyObject *)(op);	\
                        (op) = NULL;		\
                        Py_DECREF(tmp);		\
                }				\
        } while (0)


#define Py_VISIT(op)							\
        do { 								\
                if (op) {						\
                        int vret = visit((PyObject *)(op), arg);	\
                        if (vret)					\
                                return vret;				\
                }							\
        } while (0)

#endif



#if PY_VERSION_HEX < 0x020500F0

typedef int Py_ssize_t;
# define PY_SSIZE_T_MAX INT_MAX
# define PY_SSIZE_T_MIN INT_MIN
typedef inquiry lenfunc;
typedef intargfunc ssizeargfunc;
typedef intobjargproc ssizeobjargproc;

#endif


#if     __GNUC__ > 2
# define PYBINDGEN_UNUSED(param) param __attribute__((__unused__))
#elif     __GNUC__ > 2 || (__GNUC__ == 2 && __GNUC_MINOR__ > 4)
# define PYBINDGEN_UNUSED(param) __attribute__((__unused__)) param
#else
# define PYBINDGEN_UNUSED(param) param
#endif  /* !__GNUC__ */

typedef enum _PyBindGenWrapperFlags {
   PYBINDGEN_WRAPPER_FLAG_NONE = 0,
   PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED = (1<<0),
} PyBindGenWrapperFlags;


#include <stdexcept>
#include <Eigen/Core>
#include <Eigen/Geometry>
#include "EigenTypedef.h"
#include "EigenUtils.h"
#include <ostream>
#include <sstream>
/* --- forward declarations --- */


typedef struct {
    PyObject_HEAD
    Eigen::Vector2d *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenVector2d;


extern PyTypeObject PyEigenVector2d_Type;


typedef struct {
    PyObject_HEAD
    Eigen::Matrix2d *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenMatrix2d;


extern PyTypeObject PyEigenMatrix2d_Type;


typedef struct {
    PyObject_HEAD
    Eigen::Vector3d *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenVector3d;


extern PyTypeObject PyEigenVector3d_Type;


typedef struct {
    PyObject_HEAD
    Eigen::Matrix3d *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenMatrix3d;


extern PyTypeObject PyEigenMatrix3d_Type;


typedef struct {
    PyObject_HEAD
    Eigen::Vector4d *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenVector4d;


extern PyTypeObject PyEigenVector4d_Type;


typedef struct {
    PyObject_HEAD
    Eigen::Matrix4d *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenMatrix4d;


extern PyTypeObject PyEigenMatrix4d_Type;


typedef struct {
    PyObject_HEAD
    Eigen::Vector6d *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenVector6d;


extern PyTypeObject PyEigenVector6d_Type;


typedef struct {
    PyObject_HEAD
    Eigen::Matrix6d *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenMatrix6d;


extern PyTypeObject PyEigenMatrix6d_Type;


typedef struct {
    PyObject_HEAD
    Eigen::MatrixXd *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenMatrixXd;


extern PyTypeObject PyEigenMatrixXd_Type;


typedef struct {
    PyObject_HEAD
    Eigen::VectorXd *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenVectorXd;


extern PyTypeObject PyEigenVectorXd_Type;


typedef struct {
    PyObject_HEAD
    Eigen::Quaterniond *obj;
    PyBindGenWrapperFlags flags:8;
} PyEigenQuaterniond;


extern PyTypeObject PyEigenQuaterniond_Type;


PyObject* _wrap_convert_c2py__Eigen__Vector2d(Eigen::Vector2d *cvalue);


int _wrap_convert_py2c__Eigen__Vector2d(PyObject *value, Eigen::Vector2d *address);


int _wrap_convert_py2c__double(PyObject *value, double *address);


PyObject* _wrap_convert_c2py__Eigen__Matrix2d(Eigen::Matrix2d *cvalue);


int _wrap_convert_py2c__Eigen__Matrix2d(PyObject *value, Eigen::Matrix2d *address);


PyObject* _wrap_convert_c2py__Eigen__Vector3d(Eigen::Vector3d *cvalue);


int _wrap_convert_py2c__Eigen__Vector3d(PyObject *value, Eigen::Vector3d *address);


PyObject* _wrap_convert_c2py__Eigen__Matrix3d(Eigen::Matrix3d *cvalue);


int _wrap_convert_py2c__Eigen__Matrix3d(PyObject *value, Eigen::Matrix3d *address);


PyObject* _wrap_convert_c2py__Eigen__Vector4d(Eigen::Vector4d *cvalue);


int _wrap_convert_py2c__Eigen__Vector4d(PyObject *value, Eigen::Vector4d *address);


PyObject* _wrap_convert_c2py__Eigen__Matrix4d(Eigen::Matrix4d *cvalue);


int _wrap_convert_py2c__Eigen__Matrix4d(PyObject *value, Eigen::Matrix4d *address);


PyObject* _wrap_convert_c2py__Eigen__Vector6d(Eigen::Vector6d *cvalue);


int _wrap_convert_py2c__Eigen__Vector6d(PyObject *value, Eigen::Vector6d *address);


PyObject* _wrap_convert_c2py__Eigen__Matrix6d(Eigen::Matrix6d *cvalue);


int _wrap_convert_py2c__Eigen__Matrix6d(PyObject *value, Eigen::Matrix6d *address);


int _wrap_convert_py2c__Eigen__MatrixXd(PyObject *value, Eigen::MatrixXd *address);


int _wrap_convert_py2c__Eigen__VectorXd(PyObject *value, Eigen::VectorXd *address);


PyObject* _wrap_convert_c2py__Eigen__Quaterniond(Eigen::Quaterniond *cvalue);


int _wrap_convert_py2c__Eigen__Quaterniond(PyObject *value, Eigen::Quaterniond *address);

static PyMethodDef _eigen3_functions[] = {
    {NULL, NULL, 0, NULL}
};
/* --- classes --- */




static int
_wrap_PyEigenVector2d__tp_init__0(PyEigenVector2d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector2d();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVector2d__tp_init__1(PyEigenVector2d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenVector2d *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector2d_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector2d(*((PyEigenVector2d *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVector2d__tp_init__2(PyEigenVector2d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    double val;
    double val2;
    const char *keywords[] = {"val", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dd", (char **) keywords, &val, &val2)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector2d(val, val2);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenVector2d__tp_init(PyEigenVector2d *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyEigenVector2d__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVector2d__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyEigenVector2d__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenVector2d_normalize(PyEigenVector2d *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_rows(PyEigenVector2d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d___getitem__(PyEigenVector2d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_UnitY(void)
{
    PyObject *py_retval;
    PyEigenVector2d *py_Vector2d;

    Eigen::Vector2d retval = Eigen::Vector2d::UnitY();
    py_Vector2d = PyObject_New(PyEigenVector2d, &PyEigenVector2d_Type);
    py_Vector2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector2d->obj = new Eigen::Vector2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector2d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_dot(PyEigenVector2d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyEigenVector2d *v2;
    const char *keywords[] = {"v2", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector2d_Type, &v2)) {
        return NULL;
    }
    retval = self->obj->dot(*((PyEigenVector2d *) v2)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}



PyObject *
_wrap_PyEigenVector2d_coeff__0(PyEigenVector2d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenVector2d_coeff__1(PyEigenVector2d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenVector2d_coeff(PyEigenVector2d *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenVector2d_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVector2d_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenVector2d_Random(void)
{
    PyObject *py_retval;
    PyEigenVector2d *py_Vector2d;

    Eigen::Vector2d retval = Eigen::Vector2d::Random();
    py_Vector2d = PyObject_New(PyEigenVector2d, &PyEigenVector2d_Type);
    py_Vector2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector2d->obj = new Eigen::Vector2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector2d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_transpose(PyEigenVector2d *self)
{
    PyObject *py_retval;
    PyEigenMatrixXd *py_MatrixXd;

    Eigen::MatrixXd retval = self->obj->transpose();
    py_MatrixXd = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_MatrixXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_MatrixXd->obj = new Eigen::MatrixXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_MatrixXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_cols(PyEigenVector2d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d___setitem__(PyEigenVector2d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_UnitX(void)
{
    PyObject *py_retval;
    PyEigenVector2d *py_Vector2d;

    Eigen::Vector2d retval = Eigen::Vector2d::UnitX();
    py_Vector2d = PyObject_New(PyEigenVector2d, &PyEigenVector2d_Type);
    py_Vector2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector2d->obj = new Eigen::Vector2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector2d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_norm(PyEigenVector2d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_x(PyEigenVector2d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->x();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_y(PyEigenVector2d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->y();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_Zero(void)
{
    PyObject *py_retval;
    PyEigenVector2d *py_Vector2d;

    Eigen::Vector2d retval = Eigen::Vector2d::Zero();
    py_Vector2d = PyObject_New(PyEigenVector2d, &PyEigenVector2d_Type);
    py_Vector2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector2d->obj = new Eigen::Vector2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector2d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_squaredNorm(PyEigenVector2d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d___len__(PyEigenVector2d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector2d_normalized(PyEigenVector2d *self)
{
    PyObject *py_retval;
    PyEigenVector2d *py_Vector2d;

    Eigen::Vector2d retval = self->obj->normalized();
    py_Vector2d = PyObject_New(PyEigenVector2d, &PyEigenVector2d_Type);
    py_Vector2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector2d->obj = new Eigen::Vector2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector2d);
    return py_retval;
}


static PyObject*
_wrap_PyEigenVector2d__copy__(PyEigenVector2d *self)
{

    PyEigenVector2d *py_copy;
    py_copy = PyObject_New(PyEigenVector2d, &PyEigenVector2d_Type);
    py_copy->obj = new Eigen::Vector2d(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenVector2d_methods[] = {
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenVector2d_normalize, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenVector2d_rows, METH_NOARGS, NULL },
    {(char *) "UnitY", (PyCFunction) _wrap_PyEigenVector2d_UnitY, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "dot", (PyCFunction) _wrap_PyEigenVector2d_dot, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenVector2d_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenVector2d_Random, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "transpose", (PyCFunction) _wrap_PyEigenVector2d_transpose, METH_NOARGS, NULL },
    {(char *) "cols", (PyCFunction) _wrap_PyEigenVector2d_cols, METH_NOARGS, NULL },
    {(char *) "UnitX", (PyCFunction) _wrap_PyEigenVector2d_UnitX, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenVector2d_norm, METH_NOARGS, NULL },
    {(char *) "x", (PyCFunction) _wrap_PyEigenVector2d_x, METH_NOARGS, NULL },
    {(char *) "y", (PyCFunction) _wrap_PyEigenVector2d_y, METH_NOARGS, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenVector2d_Zero, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenVector2d_squaredNorm, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenVector2d_normalized, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenVector2d__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenVector2d__tp_dealloc(PyEigenVector2d *self)
{
        Eigen::Vector2d *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenVector2d__tp_str(PyEigenVector2d *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenVector2d__tp_richcompare (PyEigenVector2d *PYBINDGEN_UNUSED(self), PyEigenVector2d *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenVector2d_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Eigen__Vector2d(Eigen::Vector2d *cvalue)
{
    PyObject *py_retval;
    PyEigenVector2d *py_Vector2d;

    py_Vector2d = PyObject_New(PyEigenVector2d, &PyEigenVector2d_Type);
    py_Vector2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector2d->obj = new Eigen::Vector2d(*cvalue);
    py_retval = Py_BuildValue((char *) "N", py_Vector2d);
    return py_retval;
}


int _wrap_convert_py2c__Eigen__Vector2d(PyObject *value, Eigen::Vector2d *address)
{
    PyObject *py_retval;
    PyEigenVector2d *tmp_Vector2d;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenVector2d_Type, &tmp_Vector2d)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Vector2d->obj;
    Py_DECREF(py_retval);
    return 1;
}


int _wrap_convert_py2c__double(PyObject *value, double *address)
{
    PyObject *py_retval;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "d", &*address)) {
        Py_DECREF(py_retval);
        return 0;
    }
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
EigenVector2d__nb_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector2d left;
        Eigen::Vector2d right;
        if (_wrap_convert_py2c__Eigen__Vector2d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector2d(py_right, &right)) {
            Eigen::Vector2d result = (left + right);
            return _wrap_convert_c2py__Eigen__Vector2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector2d__nb_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector2d left;
        Eigen::Vector2d right;
        if (_wrap_convert_py2c__Eigen__Vector2d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector2d(py_right, &right)) {
            Eigen::Vector2d result = (left - right);
            return _wrap_convert_c2py__Eigen__Vector2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector2d__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        double left;
        Eigen::Vector2d right;
        if (_wrap_convert_py2c__double(py_left, &left) && _wrap_convert_py2c__Eigen__Vector2d(py_right, &right)) {
            Eigen::Vector2d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector2d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Vector2d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Vector2d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Vector2d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector2d__nb_divide (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector2d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Vector2d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Vector2d result = (left / right);
            return _wrap_convert_c2py__Eigen__Vector2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector2d__nb_inplace_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector2d left;
        Eigen::Vector2d right;
        if (_wrap_convert_py2c__Eigen__Vector2d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector2d(py_right, &right)) {
            Eigen::Vector2d result = (left += right);
            return _wrap_convert_c2py__Eigen__Vector2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector2d__nb_inplace_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector2d left;
        Eigen::Vector2d right;
        if (_wrap_convert_py2c__Eigen__Vector2d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector2d(py_right, &right)) {
            Eigen::Vector2d result = (left -= right);
            return _wrap_convert_c2py__Eigen__Vector2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector2d__nb_negative (PyObject *py_self)
{
    {
        Eigen::Vector2d self;
        if (_wrap_convert_py2c__Eigen__Vector2d(py_self, &self)) {
            Eigen::Vector2d result = -(self);
            return _wrap_convert_c2py__Eigen__Vector2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods EigenVector2d__py_number_methods = {
    (binaryfunc) EigenVector2d__nb_add,
    (binaryfunc) EigenVector2d__nb_subtract,
    (binaryfunc) EigenVector2d__nb_multiply,
    (binaryfunc) EigenVector2d__nb_divide,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) EigenVector2d__nb_negative,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) EigenVector2d__nb_inplace_add,
    (binaryfunc) EigenVector2d__nb_inplace_subtract,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};


static Py_ssize_t
EigenVector2d__sq_length (PyEigenVector2d *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenVector2d___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenVector2d__sq_item (PyEigenVector2d *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenVector2d___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenVector2d__sq_ass_item (PyEigenVector2d *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenVector2d___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenVector2d__py_sequence_methods = {
    (lenfunc) EigenVector2d__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenVector2d__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenVector2d__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenVector2d_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.Vector2d",            /* tp_name */
    sizeof(PyEigenVector2d),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenVector2d__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&EigenVector2d__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)&EigenVector2d__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenVector2d__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenVector2d__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenVector2d_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenVector2d__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenMatrix2d__tp_init__0(PyEigenMatrix2d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Matrix2d();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenMatrix2d__tp_init__1(PyEigenMatrix2d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenMatrix2d *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenMatrix2d_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Matrix2d(*((PyEigenMatrix2d *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenMatrix2d__tp_init(PyEigenMatrix2d *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenMatrix2d__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrix2d__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenMatrix2d_normalize(PyEigenMatrix2d *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d_inverse(PyEigenMatrix2d *self)
{
    PyObject *py_retval;
    PyEigenMatrix2d *py_Matrix2d;

    Eigen::Matrix2d retval = self->obj->inverse();
    py_Matrix2d = PyObject_New(PyEigenMatrix2d, &PyEigenMatrix2d_Type);
    py_Matrix2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix2d->obj = new Eigen::Matrix2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix2d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d_rows(PyEigenMatrix2d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d___getitem__(PyEigenMatrix2d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}



PyObject *
_wrap_PyEigenMatrix2d_coeff__0(PyEigenMatrix2d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenMatrix2d_coeff__1(PyEigenMatrix2d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenMatrix2d_coeff(PyEigenMatrix2d *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenMatrix2d_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrix2d_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenMatrix2d_Random(void)
{
    PyObject *py_retval;
    PyEigenMatrix2d *py_Matrix2d;

    Eigen::Matrix2d retval = Eigen::Matrix2d::Random();
    py_Matrix2d = PyObject_New(PyEigenMatrix2d, &PyEigenMatrix2d_Type);
    py_Matrix2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix2d->obj = new Eigen::Matrix2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix2d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d_transpose(PyEigenMatrix2d *self)
{
    PyObject *py_retval;
    PyEigenMatrix2d *py_Matrix2d;

    Eigen::Matrix2d retval = self->obj->transpose();
    py_Matrix2d = PyObject_New(PyEigenMatrix2d, &PyEigenMatrix2d_Type);
    py_Matrix2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix2d->obj = new Eigen::Matrix2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix2d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d_cols(PyEigenMatrix2d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d___setitem__(PyEigenMatrix2d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d_Identity(void)
{
    PyObject *py_retval;
    PyEigenMatrix2d *py_Matrix2d;

    Eigen::Matrix2d retval = Eigen::Matrix2d::Identity();
    py_Matrix2d = PyObject_New(PyEigenMatrix2d, &PyEigenMatrix2d_Type);
    py_Matrix2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix2d->obj = new Eigen::Matrix2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix2d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d_norm(PyEigenMatrix2d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d_Zero(void)
{
    PyObject *py_retval;
    PyEigenMatrix2d *py_Matrix2d;

    Eigen::Matrix2d retval = Eigen::Matrix2d::Zero();
    py_Matrix2d = PyObject_New(PyEigenMatrix2d, &PyEigenMatrix2d_Type);
    py_Matrix2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix2d->obj = new Eigen::Matrix2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix2d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d_squaredNorm(PyEigenMatrix2d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d___len__(PyEigenMatrix2d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix2d_normalized(PyEigenMatrix2d *self)
{
    PyObject *py_retval;
    PyEigenMatrix2d *py_Matrix2d;

    Eigen::Matrix2d retval = self->obj->normalized();
    py_Matrix2d = PyObject_New(PyEigenMatrix2d, &PyEigenMatrix2d_Type);
    py_Matrix2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix2d->obj = new Eigen::Matrix2d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix2d);
    return py_retval;
}


static PyObject*
_wrap_PyEigenMatrix2d__copy__(PyEigenMatrix2d *self)
{

    PyEigenMatrix2d *py_copy;
    py_copy = PyObject_New(PyEigenMatrix2d, &PyEigenMatrix2d_Type);
    py_copy->obj = new Eigen::Matrix2d(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenMatrix2d_methods[] = {
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenMatrix2d_normalize, METH_NOARGS, NULL },
    {(char *) "inverse", (PyCFunction) _wrap_PyEigenMatrix2d_inverse, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenMatrix2d_rows, METH_NOARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenMatrix2d_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenMatrix2d_Random, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "transpose", (PyCFunction) _wrap_PyEigenMatrix2d_transpose, METH_NOARGS, NULL },
    {(char *) "cols", (PyCFunction) _wrap_PyEigenMatrix2d_cols, METH_NOARGS, NULL },
    {(char *) "Identity", (PyCFunction) _wrap_PyEigenMatrix2d_Identity, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenMatrix2d_norm, METH_NOARGS, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenMatrix2d_Zero, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenMatrix2d_squaredNorm, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenMatrix2d_normalized, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenMatrix2d__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenMatrix2d__tp_dealloc(PyEigenMatrix2d *self)
{
        Eigen::Matrix2d *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenMatrix2d__tp_str(PyEigenMatrix2d *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenMatrix2d__tp_richcompare (PyEigenMatrix2d *PYBINDGEN_UNUSED(self), PyEigenMatrix2d *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenMatrix2d_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Eigen__Matrix2d(Eigen::Matrix2d *cvalue)
{
    PyObject *py_retval;
    PyEigenMatrix2d *py_Matrix2d;

    py_Matrix2d = PyObject_New(PyEigenMatrix2d, &PyEigenMatrix2d_Type);
    py_Matrix2d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix2d->obj = new Eigen::Matrix2d(*cvalue);
    py_retval = Py_BuildValue((char *) "N", py_Matrix2d);
    return py_retval;
}


int _wrap_convert_py2c__Eigen__Matrix2d(PyObject *value, Eigen::Matrix2d *address)
{
    PyObject *py_retval;
    PyEigenMatrix2d *tmp_Matrix2d;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenMatrix2d_Type, &tmp_Matrix2d)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Matrix2d->obj;
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
EigenMatrix2d__nb_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix2d left;
        Eigen::Matrix2d right;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix2d(py_right, &right)) {
            Eigen::Matrix2d result = (left + right);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix2d__nb_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix2d left;
        Eigen::Matrix2d right;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix2d(py_right, &right)) {
            Eigen::Matrix2d result = (left - right);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix2d__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        double left;
        Eigen::Matrix2d right;
        if (_wrap_convert_py2c__double(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix2d(py_right, &right)) {
            Eigen::Matrix2d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix2d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Matrix2d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix2d left;
        Eigen::Vector2d right;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector2d(py_right, &right)) {
            Eigen::Vector2d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector2d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix2d left;
        Eigen::Matrix2d right;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix2d(py_right, &right)) {
            Eigen::Matrix2d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix2d__nb_divide (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix2d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Matrix2d result = (left / right);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix2d__nb_inplace_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix2d left;
        Eigen::Matrix2d right;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix2d(py_right, &right)) {
            Eigen::Matrix2d result = (left += right);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix2d__nb_inplace_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix2d left;
        Eigen::Matrix2d right;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix2d(py_right, &right)) {
            Eigen::Matrix2d result = (left -= right);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix2d__nb_inplace_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix2d left;
        Eigen::Matrix2d right;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix2d(py_right, &right)) {
            Eigen::Matrix2d result = (left *= right);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix2d__nb_negative (PyObject *py_self)
{
    {
        Eigen::Matrix2d self;
        if (_wrap_convert_py2c__Eigen__Matrix2d(py_self, &self)) {
            Eigen::Matrix2d result = -(self);
            return _wrap_convert_c2py__Eigen__Matrix2d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods EigenMatrix2d__py_number_methods = {
    (binaryfunc) EigenMatrix2d__nb_add,
    (binaryfunc) EigenMatrix2d__nb_subtract,
    (binaryfunc) EigenMatrix2d__nb_multiply,
    (binaryfunc) EigenMatrix2d__nb_divide,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) EigenMatrix2d__nb_negative,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) EigenMatrix2d__nb_inplace_add,
    (binaryfunc) EigenMatrix2d__nb_inplace_subtract,
    (binaryfunc) EigenMatrix2d__nb_inplace_multiply,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};


static Py_ssize_t
EigenMatrix2d__sq_length (PyEigenMatrix2d *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenMatrix2d___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenMatrix2d__sq_item (PyEigenMatrix2d *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenMatrix2d___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenMatrix2d__sq_ass_item (PyEigenMatrix2d *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenMatrix2d___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenMatrix2d__py_sequence_methods = {
    (lenfunc) EigenMatrix2d__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenMatrix2d__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenMatrix2d__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenMatrix2d_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.Matrix2d",            /* tp_name */
    sizeof(PyEigenMatrix2d),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenMatrix2d__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&EigenMatrix2d__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)&EigenMatrix2d__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenMatrix2d__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenMatrix2d__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenMatrix2d_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenMatrix2d__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenVector3d__tp_init__0(PyEigenVector3d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector3d();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVector3d__tp_init__1(PyEigenVector3d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenVector3d *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector3d_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector3d(*((PyEigenVector3d *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVector3d__tp_init__2(PyEigenVector3d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    double val;
    double val2;
    double val3;
    const char *keywords[] = {"val", "val", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ddd", (char **) keywords, &val, &val2, &val3)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector3d(val, val2, val3);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenVector3d__tp_init(PyEigenVector3d *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyEigenVector3d__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVector3d__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyEigenVector3d__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenVector3d_normalize(PyEigenVector3d *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_rows(PyEigenVector3d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d___getitem__(PyEigenVector3d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_UnitY(void)
{
    PyObject *py_retval;
    PyEigenVector3d *py_Vector3d;

    Eigen::Vector3d retval = Eigen::Vector3d::UnitY();
    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_dot(PyEigenVector3d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyEigenVector3d *v2;
    const char *keywords[] = {"v2", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector3d_Type, &v2)) {
        return NULL;
    }
    retval = self->obj->dot(*((PyEigenVector3d *) v2)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}



PyObject *
_wrap_PyEigenVector3d_coeff__0(PyEigenVector3d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenVector3d_coeff__1(PyEigenVector3d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenVector3d_coeff(PyEigenVector3d *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenVector3d_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVector3d_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenVector3d_Random(void)
{
    PyObject *py_retval;
    PyEigenVector3d *py_Vector3d;

    Eigen::Vector3d retval = Eigen::Vector3d::Random();
    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_transpose(PyEigenVector3d *self)
{
    PyObject *py_retval;
    PyEigenMatrixXd *py_MatrixXd;

    Eigen::MatrixXd retval = self->obj->transpose();
    py_MatrixXd = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_MatrixXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_MatrixXd->obj = new Eigen::MatrixXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_MatrixXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_cols(PyEigenVector3d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_cross(PyEigenVector3d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyEigenVector3d *v2;
    const char *keywords[] = {"v2", NULL};
    PyEigenVector3d *py_Vector3d;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector3d_Type, &v2)) {
        return NULL;
    }
    Eigen::Vector3d retval = self->obj->cross(*((PyEigenVector3d *) v2)->obj);
    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_UnitZ(void)
{
    PyObject *py_retval;
    PyEigenVector3d *py_Vector3d;

    Eigen::Vector3d retval = Eigen::Vector3d::UnitZ();
    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d___setitem__(PyEigenVector3d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_UnitX(void)
{
    PyObject *py_retval;
    PyEigenVector3d *py_Vector3d;

    Eigen::Vector3d retval = Eigen::Vector3d::UnitX();
    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_norm(PyEigenVector3d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_x(PyEigenVector3d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->x();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_y(PyEigenVector3d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->y();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_Zero(void)
{
    PyObject *py_retval;
    PyEigenVector3d *py_Vector3d;

    Eigen::Vector3d retval = Eigen::Vector3d::Zero();
    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_squaredNorm(PyEigenVector3d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_z(PyEigenVector3d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->z();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d___len__(PyEigenVector3d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector3d_normalized(PyEigenVector3d *self)
{
    PyObject *py_retval;
    PyEigenVector3d *py_Vector3d;

    Eigen::Vector3d retval = self->obj->normalized();
    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


static PyObject*
_wrap_PyEigenVector3d__copy__(PyEigenVector3d *self)
{

    PyEigenVector3d *py_copy;
    py_copy = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_copy->obj = new Eigen::Vector3d(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenVector3d_methods[] = {
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenVector3d_normalize, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenVector3d_rows, METH_NOARGS, NULL },
    {(char *) "UnitY", (PyCFunction) _wrap_PyEigenVector3d_UnitY, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "dot", (PyCFunction) _wrap_PyEigenVector3d_dot, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenVector3d_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenVector3d_Random, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "transpose", (PyCFunction) _wrap_PyEigenVector3d_transpose, METH_NOARGS, NULL },
    {(char *) "cols", (PyCFunction) _wrap_PyEigenVector3d_cols, METH_NOARGS, NULL },
    {(char *) "cross", (PyCFunction) _wrap_PyEigenVector3d_cross, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "UnitZ", (PyCFunction) _wrap_PyEigenVector3d_UnitZ, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "UnitX", (PyCFunction) _wrap_PyEigenVector3d_UnitX, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenVector3d_norm, METH_NOARGS, NULL },
    {(char *) "x", (PyCFunction) _wrap_PyEigenVector3d_x, METH_NOARGS, NULL },
    {(char *) "y", (PyCFunction) _wrap_PyEigenVector3d_y, METH_NOARGS, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenVector3d_Zero, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenVector3d_squaredNorm, METH_NOARGS, NULL },
    {(char *) "z", (PyCFunction) _wrap_PyEigenVector3d_z, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenVector3d_normalized, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenVector3d__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenVector3d__tp_dealloc(PyEigenVector3d *self)
{
        Eigen::Vector3d *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenVector3d__tp_str(PyEigenVector3d *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenVector3d__tp_richcompare (PyEigenVector3d *PYBINDGEN_UNUSED(self), PyEigenVector3d *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenVector3d_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Eigen__Vector3d(Eigen::Vector3d *cvalue)
{
    PyObject *py_retval;
    PyEigenVector3d *py_Vector3d;

    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(*cvalue);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


int _wrap_convert_py2c__Eigen__Vector3d(PyObject *value, Eigen::Vector3d *address)
{
    PyObject *py_retval;
    PyEigenVector3d *tmp_Vector3d;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenVector3d_Type, &tmp_Vector3d)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Vector3d->obj;
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
EigenVector3d__nb_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector3d left;
        Eigen::Vector3d right;
        if (_wrap_convert_py2c__Eigen__Vector3d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector3d(py_right, &right)) {
            Eigen::Vector3d result = (left + right);
            return _wrap_convert_c2py__Eigen__Vector3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector3d__nb_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector3d left;
        Eigen::Vector3d right;
        if (_wrap_convert_py2c__Eigen__Vector3d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector3d(py_right, &right)) {
            Eigen::Vector3d result = (left - right);
            return _wrap_convert_c2py__Eigen__Vector3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector3d__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        double left;
        Eigen::Vector3d right;
        if (_wrap_convert_py2c__double(py_left, &left) && _wrap_convert_py2c__Eigen__Vector3d(py_right, &right)) {
            Eigen::Vector3d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector3d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Vector3d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Vector3d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Vector3d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector3d__nb_divide (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector3d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Vector3d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Vector3d result = (left / right);
            return _wrap_convert_c2py__Eigen__Vector3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector3d__nb_inplace_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector3d left;
        Eigen::Vector3d right;
        if (_wrap_convert_py2c__Eigen__Vector3d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector3d(py_right, &right)) {
            Eigen::Vector3d result = (left += right);
            return _wrap_convert_c2py__Eigen__Vector3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector3d__nb_inplace_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector3d left;
        Eigen::Vector3d right;
        if (_wrap_convert_py2c__Eigen__Vector3d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector3d(py_right, &right)) {
            Eigen::Vector3d result = (left -= right);
            return _wrap_convert_c2py__Eigen__Vector3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector3d__nb_negative (PyObject *py_self)
{
    {
        Eigen::Vector3d self;
        if (_wrap_convert_py2c__Eigen__Vector3d(py_self, &self)) {
            Eigen::Vector3d result = -(self);
            return _wrap_convert_c2py__Eigen__Vector3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods EigenVector3d__py_number_methods = {
    (binaryfunc) EigenVector3d__nb_add,
    (binaryfunc) EigenVector3d__nb_subtract,
    (binaryfunc) EigenVector3d__nb_multiply,
    (binaryfunc) EigenVector3d__nb_divide,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) EigenVector3d__nb_negative,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) EigenVector3d__nb_inplace_add,
    (binaryfunc) EigenVector3d__nb_inplace_subtract,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};


static Py_ssize_t
EigenVector3d__sq_length (PyEigenVector3d *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenVector3d___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenVector3d__sq_item (PyEigenVector3d *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenVector3d___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenVector3d__sq_ass_item (PyEigenVector3d *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenVector3d___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenVector3d__py_sequence_methods = {
    (lenfunc) EigenVector3d__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenVector3d__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenVector3d__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenVector3d_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.Vector3d",            /* tp_name */
    sizeof(PyEigenVector3d),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenVector3d__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&EigenVector3d__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)&EigenVector3d__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenVector3d__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenVector3d__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenVector3d_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenVector3d__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenMatrix3d__tp_init__0(PyEigenMatrix3d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Matrix3d();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenMatrix3d__tp_init__1(PyEigenMatrix3d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenMatrix3d *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenMatrix3d_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Matrix3d(*((PyEigenMatrix3d *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenMatrix3d__tp_init(PyEigenMatrix3d *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenMatrix3d__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrix3d__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenMatrix3d_normalize(PyEigenMatrix3d *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_inverse(PyEigenMatrix3d *self)
{
    PyObject *py_retval;
    PyEigenMatrix3d *py_Matrix3d;

    Eigen::Matrix3d retval = self->obj->inverse();
    py_Matrix3d = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_Matrix3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix3d->obj = new Eigen::Matrix3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_rows(PyEigenMatrix3d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_eulerAngles(PyEigenMatrix3d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int a0;
    int a1;
    int a2;
    const char *keywords[] = {"a0", "a1", "a2", NULL};
    PyEigenVector3d *py_Vector3d;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iii", (char **) keywords, &a0, &a1, &a2)) {
        return NULL;
    }
    Eigen::Vector3d retval = self->obj->eulerAngles(a0, a1, a2);
    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d___getitem__(PyEigenMatrix3d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}



PyObject *
_wrap_PyEigenMatrix3d_coeff__0(PyEigenMatrix3d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenMatrix3d_coeff__1(PyEigenMatrix3d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenMatrix3d_coeff(PyEigenMatrix3d *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenMatrix3d_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrix3d_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenMatrix3d_Random(void)
{
    PyObject *py_retval;
    PyEigenMatrix3d *py_Matrix3d;

    Eigen::Matrix3d retval = Eigen::Matrix3d::Random();
    py_Matrix3d = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_Matrix3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix3d->obj = new Eigen::Matrix3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_transpose(PyEigenMatrix3d *self)
{
    PyObject *py_retval;
    PyEigenMatrix3d *py_Matrix3d;

    Eigen::Matrix3d retval = self->obj->transpose();
    py_Matrix3d = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_Matrix3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix3d->obj = new Eigen::Matrix3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_cols(PyEigenMatrix3d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d___setitem__(PyEigenMatrix3d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_Identity(void)
{
    PyObject *py_retval;
    PyEigenMatrix3d *py_Matrix3d;

    Eigen::Matrix3d retval = Eigen::Matrix3d::Identity();
    py_Matrix3d = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_Matrix3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix3d->obj = new Eigen::Matrix3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_norm(PyEigenMatrix3d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_Zero(void)
{
    PyObject *py_retval;
    PyEigenMatrix3d *py_Matrix3d;

    Eigen::Matrix3d retval = Eigen::Matrix3d::Zero();
    py_Matrix3d = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_Matrix3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix3d->obj = new Eigen::Matrix3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_squaredNorm(PyEigenMatrix3d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d___len__(PyEigenMatrix3d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix3d_normalized(PyEigenMatrix3d *self)
{
    PyObject *py_retval;
    PyEigenMatrix3d *py_Matrix3d;

    Eigen::Matrix3d retval = self->obj->normalized();
    py_Matrix3d = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_Matrix3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix3d->obj = new Eigen::Matrix3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix3d);
    return py_retval;
}


static PyObject*
_wrap_PyEigenMatrix3d__copy__(PyEigenMatrix3d *self)
{

    PyEigenMatrix3d *py_copy;
    py_copy = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_copy->obj = new Eigen::Matrix3d(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenMatrix3d_methods[] = {
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenMatrix3d_normalize, METH_NOARGS, NULL },
    {(char *) "inverse", (PyCFunction) _wrap_PyEigenMatrix3d_inverse, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenMatrix3d_rows, METH_NOARGS, NULL },
    {(char *) "eulerAngles", (PyCFunction) _wrap_PyEigenMatrix3d_eulerAngles, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenMatrix3d_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenMatrix3d_Random, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "transpose", (PyCFunction) _wrap_PyEigenMatrix3d_transpose, METH_NOARGS, NULL },
    {(char *) "cols", (PyCFunction) _wrap_PyEigenMatrix3d_cols, METH_NOARGS, NULL },
    {(char *) "Identity", (PyCFunction) _wrap_PyEigenMatrix3d_Identity, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenMatrix3d_norm, METH_NOARGS, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenMatrix3d_Zero, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenMatrix3d_squaredNorm, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenMatrix3d_normalized, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenMatrix3d__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenMatrix3d__tp_dealloc(PyEigenMatrix3d *self)
{
        Eigen::Matrix3d *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenMatrix3d__tp_str(PyEigenMatrix3d *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenMatrix3d__tp_richcompare (PyEigenMatrix3d *PYBINDGEN_UNUSED(self), PyEigenMatrix3d *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenMatrix3d_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Eigen__Matrix3d(Eigen::Matrix3d *cvalue)
{
    PyObject *py_retval;
    PyEigenMatrix3d *py_Matrix3d;

    py_Matrix3d = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_Matrix3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix3d->obj = new Eigen::Matrix3d(*cvalue);
    py_retval = Py_BuildValue((char *) "N", py_Matrix3d);
    return py_retval;
}


int _wrap_convert_py2c__Eigen__Matrix3d(PyObject *value, Eigen::Matrix3d *address)
{
    PyObject *py_retval;
    PyEigenMatrix3d *tmp_Matrix3d;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenMatrix3d_Type, &tmp_Matrix3d)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Matrix3d->obj;
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
EigenMatrix3d__nb_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix3d left;
        Eigen::Matrix3d right;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix3d(py_right, &right)) {
            Eigen::Matrix3d result = (left + right);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix3d__nb_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix3d left;
        Eigen::Matrix3d right;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix3d(py_right, &right)) {
            Eigen::Matrix3d result = (left - right);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix3d__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        double left;
        Eigen::Matrix3d right;
        if (_wrap_convert_py2c__double(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix3d(py_right, &right)) {
            Eigen::Matrix3d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix3d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Matrix3d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix3d left;
        Eigen::Vector3d right;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector3d(py_right, &right)) {
            Eigen::Vector3d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector3d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix3d left;
        Eigen::Matrix3d right;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix3d(py_right, &right)) {
            Eigen::Matrix3d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix3d__nb_divide (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix3d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Matrix3d result = (left / right);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix3d__nb_inplace_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix3d left;
        Eigen::Matrix3d right;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix3d(py_right, &right)) {
            Eigen::Matrix3d result = (left += right);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix3d__nb_inplace_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix3d left;
        Eigen::Matrix3d right;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix3d(py_right, &right)) {
            Eigen::Matrix3d result = (left -= right);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix3d__nb_inplace_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix3d left;
        Eigen::Matrix3d right;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix3d(py_right, &right)) {
            Eigen::Matrix3d result = (left *= right);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix3d__nb_negative (PyObject *py_self)
{
    {
        Eigen::Matrix3d self;
        if (_wrap_convert_py2c__Eigen__Matrix3d(py_self, &self)) {
            Eigen::Matrix3d result = -(self);
            return _wrap_convert_c2py__Eigen__Matrix3d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods EigenMatrix3d__py_number_methods = {
    (binaryfunc) EigenMatrix3d__nb_add,
    (binaryfunc) EigenMatrix3d__nb_subtract,
    (binaryfunc) EigenMatrix3d__nb_multiply,
    (binaryfunc) EigenMatrix3d__nb_divide,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) EigenMatrix3d__nb_negative,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) EigenMatrix3d__nb_inplace_add,
    (binaryfunc) EigenMatrix3d__nb_inplace_subtract,
    (binaryfunc) EigenMatrix3d__nb_inplace_multiply,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};


static Py_ssize_t
EigenMatrix3d__sq_length (PyEigenMatrix3d *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenMatrix3d___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenMatrix3d__sq_item (PyEigenMatrix3d *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenMatrix3d___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenMatrix3d__sq_ass_item (PyEigenMatrix3d *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenMatrix3d___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenMatrix3d__py_sequence_methods = {
    (lenfunc) EigenMatrix3d__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenMatrix3d__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenMatrix3d__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenMatrix3d_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.Matrix3d",            /* tp_name */
    sizeof(PyEigenMatrix3d),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenMatrix3d__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&EigenMatrix3d__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)&EigenMatrix3d__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenMatrix3d__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenMatrix3d__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenMatrix3d_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenMatrix3d__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenVector4d__tp_init__0(PyEigenVector4d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector4d();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVector4d__tp_init__1(PyEigenVector4d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenVector4d *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector4d_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector4d(*((PyEigenVector4d *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVector4d__tp_init__2(PyEigenVector4d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    double val;
    double val2;
    double val3;
    double val4;
    const char *keywords[] = {"val", "val", "val", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dddd", (char **) keywords, &val, &val2, &val3, &val4)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector4d(val, val2, val3, val4);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenVector4d__tp_init(PyEigenVector4d *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyEigenVector4d__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVector4d__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyEigenVector4d__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenVector4d_cols(PyEigenVector4d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_normalize(PyEigenVector4d *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_rows(PyEigenVector4d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_UnitZ(void)
{
    PyObject *py_retval;
    PyEigenVector4d *py_Vector4d;

    Eigen::Vector4d retval = Eigen::Vector4d::UnitZ();
    py_Vector4d = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_Vector4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector4d->obj = new Eigen::Vector4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_UnitY(void)
{
    PyObject *py_retval;
    PyEigenVector4d *py_Vector4d;

    Eigen::Vector4d retval = Eigen::Vector4d::UnitY();
    py_Vector4d = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_Vector4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector4d->obj = new Eigen::Vector4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_UnitX(void)
{
    PyObject *py_retval;
    PyEigenVector4d *py_Vector4d;

    Eigen::Vector4d retval = Eigen::Vector4d::UnitX();
    py_Vector4d = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_Vector4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector4d->obj = new Eigen::Vector4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_squaredNorm(PyEigenVector4d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_UnitW(void)
{
    PyObject *py_retval;
    PyEigenVector4d *py_Vector4d;

    Eigen::Vector4d retval = Eigen::Vector4d::UnitW();
    py_Vector4d = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_Vector4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector4d->obj = new Eigen::Vector4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_norm(PyEigenVector4d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d___getitem__(PyEigenVector4d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_transpose(PyEigenVector4d *self)
{
    PyObject *py_retval;
    PyEigenMatrixXd *py_MatrixXd;

    Eigen::MatrixXd retval = self->obj->transpose();
    py_MatrixXd = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_MatrixXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_MatrixXd->obj = new Eigen::MatrixXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_MatrixXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d___setitem__(PyEigenVector4d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_normalized(PyEigenVector4d *self)
{
    PyObject *py_retval;
    PyEigenVector4d *py_Vector4d;

    Eigen::Vector4d retval = self->obj->normalized();
    py_Vector4d = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_Vector4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector4d->obj = new Eigen::Vector4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector4d);
    return py_retval;
}



PyObject *
_wrap_PyEigenVector4d_coeff__0(PyEigenVector4d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenVector4d_coeff__1(PyEigenVector4d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenVector4d_coeff(PyEigenVector4d *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenVector4d_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVector4d_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenVector4d_Random(void)
{
    PyObject *py_retval;
    PyEigenVector4d *py_Vector4d;

    Eigen::Vector4d retval = Eigen::Vector4d::Random();
    py_Vector4d = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_Vector4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector4d->obj = new Eigen::Vector4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_Zero(void)
{
    PyObject *py_retval;
    PyEigenVector4d *py_Vector4d;

    Eigen::Vector4d retval = Eigen::Vector4d::Zero();
    py_Vector4d = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_Vector4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector4d->obj = new Eigen::Vector4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d___len__(PyEigenVector4d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_w(PyEigenVector4d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->w();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_y(PyEigenVector4d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->y();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_x(PyEigenVector4d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->x();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_z(PyEigenVector4d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->z();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector4d_dot(PyEigenVector4d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyEigenVector4d *v2;
    const char *keywords[] = {"v2", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector4d_Type, &v2)) {
        return NULL;
    }
    retval = self->obj->dot(*((PyEigenVector4d *) v2)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


static PyObject*
_wrap_PyEigenVector4d__copy__(PyEigenVector4d *self)
{

    PyEigenVector4d *py_copy;
    py_copy = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_copy->obj = new Eigen::Vector4d(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenVector4d_methods[] = {
    {(char *) "cols", (PyCFunction) _wrap_PyEigenVector4d_cols, METH_NOARGS, NULL },
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenVector4d_normalize, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenVector4d_rows, METH_NOARGS, NULL },
    {(char *) "UnitZ", (PyCFunction) _wrap_PyEigenVector4d_UnitZ, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "UnitY", (PyCFunction) _wrap_PyEigenVector4d_UnitY, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "UnitX", (PyCFunction) _wrap_PyEigenVector4d_UnitX, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenVector4d_squaredNorm, METH_NOARGS, NULL },
    {(char *) "UnitW", (PyCFunction) _wrap_PyEigenVector4d_UnitW, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenVector4d_norm, METH_NOARGS, NULL },
    {(char *) "transpose", (PyCFunction) _wrap_PyEigenVector4d_transpose, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenVector4d_normalized, METH_NOARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenVector4d_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenVector4d_Random, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenVector4d_Zero, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "w", (PyCFunction) _wrap_PyEigenVector4d_w, METH_NOARGS, NULL },
    {(char *) "y", (PyCFunction) _wrap_PyEigenVector4d_y, METH_NOARGS, NULL },
    {(char *) "x", (PyCFunction) _wrap_PyEigenVector4d_x, METH_NOARGS, NULL },
    {(char *) "z", (PyCFunction) _wrap_PyEigenVector4d_z, METH_NOARGS, NULL },
    {(char *) "dot", (PyCFunction) _wrap_PyEigenVector4d_dot, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenVector4d__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenVector4d__tp_dealloc(PyEigenVector4d *self)
{
        Eigen::Vector4d *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenVector4d__tp_str(PyEigenVector4d *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenVector4d__tp_richcompare (PyEigenVector4d *PYBINDGEN_UNUSED(self), PyEigenVector4d *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenVector4d_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Eigen__Vector4d(Eigen::Vector4d *cvalue)
{
    PyObject *py_retval;
    PyEigenVector4d *py_Vector4d;

    py_Vector4d = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_Vector4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector4d->obj = new Eigen::Vector4d(*cvalue);
    py_retval = Py_BuildValue((char *) "N", py_Vector4d);
    return py_retval;
}


int _wrap_convert_py2c__Eigen__Vector4d(PyObject *value, Eigen::Vector4d *address)
{
    PyObject *py_retval;
    PyEigenVector4d *tmp_Vector4d;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenVector4d_Type, &tmp_Vector4d)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Vector4d->obj;
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
EigenVector4d__nb_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector4d left;
        Eigen::Vector4d right;
        if (_wrap_convert_py2c__Eigen__Vector4d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector4d(py_right, &right)) {
            Eigen::Vector4d result = (left + right);
            return _wrap_convert_c2py__Eigen__Vector4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector4d__nb_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector4d left;
        Eigen::Vector4d right;
        if (_wrap_convert_py2c__Eigen__Vector4d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector4d(py_right, &right)) {
            Eigen::Vector4d result = (left - right);
            return _wrap_convert_c2py__Eigen__Vector4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector4d__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        double left;
        Eigen::Vector4d right;
        if (_wrap_convert_py2c__double(py_left, &left) && _wrap_convert_py2c__Eigen__Vector4d(py_right, &right)) {
            Eigen::Vector4d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector4d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Vector4d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Vector4d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Vector4d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector4d__nb_divide (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector4d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Vector4d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Vector4d result = (left / right);
            return _wrap_convert_c2py__Eigen__Vector4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector4d__nb_inplace_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector4d left;
        Eigen::Vector4d right;
        if (_wrap_convert_py2c__Eigen__Vector4d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector4d(py_right, &right)) {
            Eigen::Vector4d result = (left += right);
            return _wrap_convert_c2py__Eigen__Vector4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector4d__nb_inplace_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector4d left;
        Eigen::Vector4d right;
        if (_wrap_convert_py2c__Eigen__Vector4d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector4d(py_right, &right)) {
            Eigen::Vector4d result = (left -= right);
            return _wrap_convert_c2py__Eigen__Vector4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector4d__nb_negative (PyObject *py_self)
{
    {
        Eigen::Vector4d self;
        if (_wrap_convert_py2c__Eigen__Vector4d(py_self, &self)) {
            Eigen::Vector4d result = -(self);
            return _wrap_convert_c2py__Eigen__Vector4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods EigenVector4d__py_number_methods = {
    (binaryfunc) EigenVector4d__nb_add,
    (binaryfunc) EigenVector4d__nb_subtract,
    (binaryfunc) EigenVector4d__nb_multiply,
    (binaryfunc) EigenVector4d__nb_divide,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) EigenVector4d__nb_negative,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) EigenVector4d__nb_inplace_add,
    (binaryfunc) EigenVector4d__nb_inplace_subtract,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};


static Py_ssize_t
EigenVector4d__sq_length (PyEigenVector4d *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenVector4d___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenVector4d__sq_item (PyEigenVector4d *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenVector4d___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenVector4d__sq_ass_item (PyEigenVector4d *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenVector4d___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenVector4d__py_sequence_methods = {
    (lenfunc) EigenVector4d__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenVector4d__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenVector4d__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenVector4d_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.Vector4d",            /* tp_name */
    sizeof(PyEigenVector4d),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenVector4d__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&EigenVector4d__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)&EigenVector4d__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenVector4d__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenVector4d__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenVector4d_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenVector4d__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenMatrix4d__tp_init__0(PyEigenMatrix4d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Matrix4d();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenMatrix4d__tp_init__1(PyEigenMatrix4d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenMatrix4d *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenMatrix4d_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Matrix4d(*((PyEigenMatrix4d *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenMatrix4d__tp_init(PyEigenMatrix4d *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenMatrix4d__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrix4d__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenMatrix4d_normalize(PyEigenMatrix4d *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d_inverse(PyEigenMatrix4d *self)
{
    PyObject *py_retval;
    PyEigenMatrix4d *py_Matrix4d;

    Eigen::Matrix4d retval = self->obj->inverse();
    py_Matrix4d = PyObject_New(PyEigenMatrix4d, &PyEigenMatrix4d_Type);
    py_Matrix4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix4d->obj = new Eigen::Matrix4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d_rows(PyEigenMatrix4d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d___getitem__(PyEigenMatrix4d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}



PyObject *
_wrap_PyEigenMatrix4d_coeff__0(PyEigenMatrix4d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenMatrix4d_coeff__1(PyEigenMatrix4d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenMatrix4d_coeff(PyEigenMatrix4d *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenMatrix4d_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrix4d_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenMatrix4d_Random(void)
{
    PyObject *py_retval;
    PyEigenMatrix4d *py_Matrix4d;

    Eigen::Matrix4d retval = Eigen::Matrix4d::Random();
    py_Matrix4d = PyObject_New(PyEigenMatrix4d, &PyEigenMatrix4d_Type);
    py_Matrix4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix4d->obj = new Eigen::Matrix4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d_transpose(PyEigenMatrix4d *self)
{
    PyObject *py_retval;
    PyEigenMatrix4d *py_Matrix4d;

    Eigen::Matrix4d retval = self->obj->transpose();
    py_Matrix4d = PyObject_New(PyEigenMatrix4d, &PyEigenMatrix4d_Type);
    py_Matrix4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix4d->obj = new Eigen::Matrix4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d_cols(PyEigenMatrix4d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d___setitem__(PyEigenMatrix4d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d_Identity(void)
{
    PyObject *py_retval;
    PyEigenMatrix4d *py_Matrix4d;

    Eigen::Matrix4d retval = Eigen::Matrix4d::Identity();
    py_Matrix4d = PyObject_New(PyEigenMatrix4d, &PyEigenMatrix4d_Type);
    py_Matrix4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix4d->obj = new Eigen::Matrix4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d_norm(PyEigenMatrix4d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d_Zero(void)
{
    PyObject *py_retval;
    PyEigenMatrix4d *py_Matrix4d;

    Eigen::Matrix4d retval = Eigen::Matrix4d::Zero();
    py_Matrix4d = PyObject_New(PyEigenMatrix4d, &PyEigenMatrix4d_Type);
    py_Matrix4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix4d->obj = new Eigen::Matrix4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d_squaredNorm(PyEigenMatrix4d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d___len__(PyEigenMatrix4d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix4d_normalized(PyEigenMatrix4d *self)
{
    PyObject *py_retval;
    PyEigenMatrix4d *py_Matrix4d;

    Eigen::Matrix4d retval = self->obj->normalized();
    py_Matrix4d = PyObject_New(PyEigenMatrix4d, &PyEigenMatrix4d_Type);
    py_Matrix4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix4d->obj = new Eigen::Matrix4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix4d);
    return py_retval;
}


static PyObject*
_wrap_PyEigenMatrix4d__copy__(PyEigenMatrix4d *self)
{

    PyEigenMatrix4d *py_copy;
    py_copy = PyObject_New(PyEigenMatrix4d, &PyEigenMatrix4d_Type);
    py_copy->obj = new Eigen::Matrix4d(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenMatrix4d_methods[] = {
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenMatrix4d_normalize, METH_NOARGS, NULL },
    {(char *) "inverse", (PyCFunction) _wrap_PyEigenMatrix4d_inverse, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenMatrix4d_rows, METH_NOARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenMatrix4d_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenMatrix4d_Random, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "transpose", (PyCFunction) _wrap_PyEigenMatrix4d_transpose, METH_NOARGS, NULL },
    {(char *) "cols", (PyCFunction) _wrap_PyEigenMatrix4d_cols, METH_NOARGS, NULL },
    {(char *) "Identity", (PyCFunction) _wrap_PyEigenMatrix4d_Identity, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenMatrix4d_norm, METH_NOARGS, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenMatrix4d_Zero, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenMatrix4d_squaredNorm, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenMatrix4d_normalized, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenMatrix4d__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenMatrix4d__tp_dealloc(PyEigenMatrix4d *self)
{
        Eigen::Matrix4d *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenMatrix4d__tp_str(PyEigenMatrix4d *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenMatrix4d__tp_richcompare (PyEigenMatrix4d *PYBINDGEN_UNUSED(self), PyEigenMatrix4d *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenMatrix4d_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Eigen__Matrix4d(Eigen::Matrix4d *cvalue)
{
    PyObject *py_retval;
    PyEigenMatrix4d *py_Matrix4d;

    py_Matrix4d = PyObject_New(PyEigenMatrix4d, &PyEigenMatrix4d_Type);
    py_Matrix4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix4d->obj = new Eigen::Matrix4d(*cvalue);
    py_retval = Py_BuildValue((char *) "N", py_Matrix4d);
    return py_retval;
}


int _wrap_convert_py2c__Eigen__Matrix4d(PyObject *value, Eigen::Matrix4d *address)
{
    PyObject *py_retval;
    PyEigenMatrix4d *tmp_Matrix4d;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenMatrix4d_Type, &tmp_Matrix4d)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Matrix4d->obj;
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
EigenMatrix4d__nb_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix4d left;
        Eigen::Matrix4d right;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix4d(py_right, &right)) {
            Eigen::Matrix4d result = (left + right);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix4d__nb_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix4d left;
        Eigen::Matrix4d right;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix4d(py_right, &right)) {
            Eigen::Matrix4d result = (left - right);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix4d__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        double left;
        Eigen::Matrix4d right;
        if (_wrap_convert_py2c__double(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix4d(py_right, &right)) {
            Eigen::Matrix4d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix4d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Matrix4d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix4d left;
        Eigen::Matrix4d right;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix4d(py_right, &right)) {
            Eigen::Matrix4d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix4d left;
        Eigen::Vector4d right;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector4d(py_right, &right)) {
            Eigen::Vector4d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix4d__nb_divide (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix4d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Matrix4d result = (left / right);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix4d__nb_inplace_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix4d left;
        Eigen::Matrix4d right;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix4d(py_right, &right)) {
            Eigen::Matrix4d result = (left += right);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix4d__nb_inplace_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix4d left;
        Eigen::Matrix4d right;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix4d(py_right, &right)) {
            Eigen::Matrix4d result = (left -= right);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix4d__nb_inplace_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix4d left;
        Eigen::Matrix4d right;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix4d(py_right, &right)) {
            Eigen::Matrix4d result = (left *= right);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix4d__nb_negative (PyObject *py_self)
{
    {
        Eigen::Matrix4d self;
        if (_wrap_convert_py2c__Eigen__Matrix4d(py_self, &self)) {
            Eigen::Matrix4d result = -(self);
            return _wrap_convert_c2py__Eigen__Matrix4d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods EigenMatrix4d__py_number_methods = {
    (binaryfunc) EigenMatrix4d__nb_add,
    (binaryfunc) EigenMatrix4d__nb_subtract,
    (binaryfunc) EigenMatrix4d__nb_multiply,
    (binaryfunc) EigenMatrix4d__nb_divide,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) EigenMatrix4d__nb_negative,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) EigenMatrix4d__nb_inplace_add,
    (binaryfunc) EigenMatrix4d__nb_inplace_subtract,
    (binaryfunc) EigenMatrix4d__nb_inplace_multiply,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};


static Py_ssize_t
EigenMatrix4d__sq_length (PyEigenMatrix4d *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenMatrix4d___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenMatrix4d__sq_item (PyEigenMatrix4d *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenMatrix4d___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenMatrix4d__sq_ass_item (PyEigenMatrix4d *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenMatrix4d___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenMatrix4d__py_sequence_methods = {
    (lenfunc) EigenMatrix4d__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenMatrix4d__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenMatrix4d__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenMatrix4d_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.Matrix4d",            /* tp_name */
    sizeof(PyEigenMatrix4d),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenMatrix4d__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&EigenMatrix4d__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)&EigenMatrix4d__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenMatrix4d__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenMatrix4d__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenMatrix4d_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenMatrix4d__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenVector6d__tp_init__0(PyEigenVector6d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector6d();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVector6d__tp_init__1(PyEigenVector6d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenVector6d *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector6d_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector6d(*((PyEigenVector6d *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVector6d__tp_init__2(PyEigenVector6d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    double val;
    double val2;
    double val3;
    double val4;
    double val5;
    double val6;
    const char *keywords[] = {"val", "val", "val", "val", "val", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dddddd", (char **) keywords, &val, &val2, &val3, &val4, &val5, &val6)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Vector6d(val, val2, val3, val4, val5, val6);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenVector6d__tp_init(PyEigenVector6d *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyEigenVector6d__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVector6d__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyEigenVector6d__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenVector6d_cols(PyEigenVector6d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_normalize(PyEigenVector6d *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_rows(PyEigenVector6d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_UnitZ(void)
{
    PyObject *py_retval;
    PyEigenVector6d *py_Vector6d;

    Eigen::Vector6d retval = Eigen::Vector6d::UnitZ();
    py_Vector6d = PyObject_New(PyEigenVector6d, &PyEigenVector6d_Type);
    py_Vector6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector6d->obj = new Eigen::Vector6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_UnitY(void)
{
    PyObject *py_retval;
    PyEigenVector6d *py_Vector6d;

    Eigen::Vector6d retval = Eigen::Vector6d::UnitY();
    py_Vector6d = PyObject_New(PyEigenVector6d, &PyEigenVector6d_Type);
    py_Vector6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector6d->obj = new Eigen::Vector6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_UnitX(void)
{
    PyObject *py_retval;
    PyEigenVector6d *py_Vector6d;

    Eigen::Vector6d retval = Eigen::Vector6d::UnitX();
    py_Vector6d = PyObject_New(PyEigenVector6d, &PyEigenVector6d_Type);
    py_Vector6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector6d->obj = new Eigen::Vector6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_squaredNorm(PyEigenVector6d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_UnitW(void)
{
    PyObject *py_retval;
    PyEigenVector6d *py_Vector6d;

    Eigen::Vector6d retval = Eigen::Vector6d::UnitW();
    py_Vector6d = PyObject_New(PyEigenVector6d, &PyEigenVector6d_Type);
    py_Vector6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector6d->obj = new Eigen::Vector6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_norm(PyEigenVector6d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d___getitem__(PyEigenVector6d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_transpose(PyEigenVector6d *self)
{
    PyObject *py_retval;
    PyEigenMatrixXd *py_MatrixXd;

    Eigen::MatrixXd retval = self->obj->transpose();
    py_MatrixXd = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_MatrixXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_MatrixXd->obj = new Eigen::MatrixXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_MatrixXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d___setitem__(PyEigenVector6d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_normalized(PyEigenVector6d *self)
{
    PyObject *py_retval;
    PyEigenVector6d *py_Vector6d;

    Eigen::Vector6d retval = self->obj->normalized();
    py_Vector6d = PyObject_New(PyEigenVector6d, &PyEigenVector6d_Type);
    py_Vector6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector6d->obj = new Eigen::Vector6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector6d);
    return py_retval;
}



PyObject *
_wrap_PyEigenVector6d_coeff__0(PyEigenVector6d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenVector6d_coeff__1(PyEigenVector6d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenVector6d_coeff(PyEigenVector6d *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenVector6d_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVector6d_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenVector6d_Random(void)
{
    PyObject *py_retval;
    PyEigenVector6d *py_Vector6d;

    Eigen::Vector6d retval = Eigen::Vector6d::Random();
    py_Vector6d = PyObject_New(PyEigenVector6d, &PyEigenVector6d_Type);
    py_Vector6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector6d->obj = new Eigen::Vector6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_Zero(void)
{
    PyObject *py_retval;
    PyEigenVector6d *py_Vector6d;

    Eigen::Vector6d retval = Eigen::Vector6d::Zero();
    py_Vector6d = PyObject_New(PyEigenVector6d, &PyEigenVector6d_Type);
    py_Vector6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector6d->obj = new Eigen::Vector6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d___len__(PyEigenVector6d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_w(PyEigenVector6d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->w();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_y(PyEigenVector6d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->y();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_x(PyEigenVector6d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->x();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_z(PyEigenVector6d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->z();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVector6d_dot(PyEigenVector6d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyEigenVector6d *v2;
    const char *keywords[] = {"v2", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector6d_Type, &v2)) {
        return NULL;
    }
    retval = self->obj->dot(*((PyEigenVector6d *) v2)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


static PyObject*
_wrap_PyEigenVector6d__copy__(PyEigenVector6d *self)
{

    PyEigenVector6d *py_copy;
    py_copy = PyObject_New(PyEigenVector6d, &PyEigenVector6d_Type);
    py_copy->obj = new Eigen::Vector6d(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenVector6d_methods[] = {
    {(char *) "cols", (PyCFunction) _wrap_PyEigenVector6d_cols, METH_NOARGS, NULL },
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenVector6d_normalize, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenVector6d_rows, METH_NOARGS, NULL },
    {(char *) "UnitZ", (PyCFunction) _wrap_PyEigenVector6d_UnitZ, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "UnitY", (PyCFunction) _wrap_PyEigenVector6d_UnitY, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "UnitX", (PyCFunction) _wrap_PyEigenVector6d_UnitX, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenVector6d_squaredNorm, METH_NOARGS, NULL },
    {(char *) "UnitW", (PyCFunction) _wrap_PyEigenVector6d_UnitW, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenVector6d_norm, METH_NOARGS, NULL },
    {(char *) "transpose", (PyCFunction) _wrap_PyEigenVector6d_transpose, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenVector6d_normalized, METH_NOARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenVector6d_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenVector6d_Random, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenVector6d_Zero, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "w", (PyCFunction) _wrap_PyEigenVector6d_w, METH_NOARGS, NULL },
    {(char *) "y", (PyCFunction) _wrap_PyEigenVector6d_y, METH_NOARGS, NULL },
    {(char *) "x", (PyCFunction) _wrap_PyEigenVector6d_x, METH_NOARGS, NULL },
    {(char *) "z", (PyCFunction) _wrap_PyEigenVector6d_z, METH_NOARGS, NULL },
    {(char *) "dot", (PyCFunction) _wrap_PyEigenVector6d_dot, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenVector6d__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenVector6d__tp_dealloc(PyEigenVector6d *self)
{
        Eigen::Vector6d *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenVector6d__tp_str(PyEigenVector6d *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenVector6d__tp_richcompare (PyEigenVector6d *PYBINDGEN_UNUSED(self), PyEigenVector6d *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenVector6d_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Eigen__Vector6d(Eigen::Vector6d *cvalue)
{
    PyObject *py_retval;
    PyEigenVector6d *py_Vector6d;

    py_Vector6d = PyObject_New(PyEigenVector6d, &PyEigenVector6d_Type);
    py_Vector6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector6d->obj = new Eigen::Vector6d(*cvalue);
    py_retval = Py_BuildValue((char *) "N", py_Vector6d);
    return py_retval;
}


int _wrap_convert_py2c__Eigen__Vector6d(PyObject *value, Eigen::Vector6d *address)
{
    PyObject *py_retval;
    PyEigenVector6d *tmp_Vector6d;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenVector6d_Type, &tmp_Vector6d)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Vector6d->obj;
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
EigenVector6d__nb_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector6d left;
        Eigen::Vector6d right;
        if (_wrap_convert_py2c__Eigen__Vector6d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector6d(py_right, &right)) {
            Eigen::Vector6d result = (left + right);
            return _wrap_convert_c2py__Eigen__Vector6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector6d__nb_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector6d left;
        Eigen::Vector6d right;
        if (_wrap_convert_py2c__Eigen__Vector6d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector6d(py_right, &right)) {
            Eigen::Vector6d result = (left - right);
            return _wrap_convert_c2py__Eigen__Vector6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector6d__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        double left;
        Eigen::Vector6d right;
        if (_wrap_convert_py2c__double(py_left, &left) && _wrap_convert_py2c__Eigen__Vector6d(py_right, &right)) {
            Eigen::Vector6d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector6d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Vector6d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Vector6d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Vector6d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector6d__nb_divide (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector6d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Vector6d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Vector6d result = (left / right);
            return _wrap_convert_c2py__Eigen__Vector6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector6d__nb_inplace_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector6d left;
        Eigen::Vector6d right;
        if (_wrap_convert_py2c__Eigen__Vector6d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector6d(py_right, &right)) {
            Eigen::Vector6d result = (left += right);
            return _wrap_convert_c2py__Eigen__Vector6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector6d__nb_inplace_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Vector6d left;
        Eigen::Vector6d right;
        if (_wrap_convert_py2c__Eigen__Vector6d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector6d(py_right, &right)) {
            Eigen::Vector6d result = (left -= right);
            return _wrap_convert_c2py__Eigen__Vector6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenVector6d__nb_negative (PyObject *py_self)
{
    {
        Eigen::Vector6d self;
        if (_wrap_convert_py2c__Eigen__Vector6d(py_self, &self)) {
            Eigen::Vector6d result = -(self);
            return _wrap_convert_c2py__Eigen__Vector6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods EigenVector6d__py_number_methods = {
    (binaryfunc) EigenVector6d__nb_add,
    (binaryfunc) EigenVector6d__nb_subtract,
    (binaryfunc) EigenVector6d__nb_multiply,
    (binaryfunc) EigenVector6d__nb_divide,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) EigenVector6d__nb_negative,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) EigenVector6d__nb_inplace_add,
    (binaryfunc) EigenVector6d__nb_inplace_subtract,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};


static Py_ssize_t
EigenVector6d__sq_length (PyEigenVector6d *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenVector6d___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenVector6d__sq_item (PyEigenVector6d *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenVector6d___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenVector6d__sq_ass_item (PyEigenVector6d *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenVector6d___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenVector6d__py_sequence_methods = {
    (lenfunc) EigenVector6d__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenVector6d__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenVector6d__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenVector6d_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.Vector6d",            /* tp_name */
    sizeof(PyEigenVector6d),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenVector6d__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&EigenVector6d__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)&EigenVector6d__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenVector6d__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenVector6d__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenVector6d_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenVector6d__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenMatrix6d__tp_init__0(PyEigenMatrix6d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Matrix6d();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenMatrix6d__tp_init__1(PyEigenMatrix6d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenMatrix6d *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenMatrix6d_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::Matrix6d(*((PyEigenMatrix6d *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenMatrix6d__tp_init(PyEigenMatrix6d *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenMatrix6d__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrix6d__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenMatrix6d_normalize(PyEigenMatrix6d *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d_inverse(PyEigenMatrix6d *self)
{
    PyObject *py_retval;
    PyEigenMatrix6d *py_Matrix6d;

    Eigen::Matrix6d retval = self->obj->inverse();
    py_Matrix6d = PyObject_New(PyEigenMatrix6d, &PyEigenMatrix6d_Type);
    py_Matrix6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix6d->obj = new Eigen::Matrix6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d_rows(PyEigenMatrix6d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d___getitem__(PyEigenMatrix6d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}



PyObject *
_wrap_PyEigenMatrix6d_coeff__0(PyEigenMatrix6d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenMatrix6d_coeff__1(PyEigenMatrix6d *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenMatrix6d_coeff(PyEigenMatrix6d *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenMatrix6d_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrix6d_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenMatrix6d_Random(void)
{
    PyObject *py_retval;
    PyEigenMatrix6d *py_Matrix6d;

    Eigen::Matrix6d retval = Eigen::Matrix6d::Random();
    py_Matrix6d = PyObject_New(PyEigenMatrix6d, &PyEigenMatrix6d_Type);
    py_Matrix6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix6d->obj = new Eigen::Matrix6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d_transpose(PyEigenMatrix6d *self)
{
    PyObject *py_retval;
    PyEigenMatrix6d *py_Matrix6d;

    Eigen::Matrix6d retval = self->obj->transpose();
    py_Matrix6d = PyObject_New(PyEigenMatrix6d, &PyEigenMatrix6d_Type);
    py_Matrix6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix6d->obj = new Eigen::Matrix6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d_cols(PyEigenMatrix6d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d___setitem__(PyEigenMatrix6d *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d_Identity(void)
{
    PyObject *py_retval;
    PyEigenMatrix6d *py_Matrix6d;

    Eigen::Matrix6d retval = Eigen::Matrix6d::Identity();
    py_Matrix6d = PyObject_New(PyEigenMatrix6d, &PyEigenMatrix6d_Type);
    py_Matrix6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix6d->obj = new Eigen::Matrix6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d_norm(PyEigenMatrix6d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d_Zero(void)
{
    PyObject *py_retval;
    PyEigenMatrix6d *py_Matrix6d;

    Eigen::Matrix6d retval = Eigen::Matrix6d::Zero();
    py_Matrix6d = PyObject_New(PyEigenMatrix6d, &PyEigenMatrix6d_Type);
    py_Matrix6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix6d->obj = new Eigen::Matrix6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix6d);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d_squaredNorm(PyEigenMatrix6d *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d___len__(PyEigenMatrix6d *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrix6d_normalized(PyEigenMatrix6d *self)
{
    PyObject *py_retval;
    PyEigenMatrix6d *py_Matrix6d;

    Eigen::Matrix6d retval = self->obj->normalized();
    py_Matrix6d = PyObject_New(PyEigenMatrix6d, &PyEigenMatrix6d_Type);
    py_Matrix6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix6d->obj = new Eigen::Matrix6d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix6d);
    return py_retval;
}


static PyObject*
_wrap_PyEigenMatrix6d__copy__(PyEigenMatrix6d *self)
{

    PyEigenMatrix6d *py_copy;
    py_copy = PyObject_New(PyEigenMatrix6d, &PyEigenMatrix6d_Type);
    py_copy->obj = new Eigen::Matrix6d(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenMatrix6d_methods[] = {
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenMatrix6d_normalize, METH_NOARGS, NULL },
    {(char *) "inverse", (PyCFunction) _wrap_PyEigenMatrix6d_inverse, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenMatrix6d_rows, METH_NOARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenMatrix6d_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenMatrix6d_Random, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "transpose", (PyCFunction) _wrap_PyEigenMatrix6d_transpose, METH_NOARGS, NULL },
    {(char *) "cols", (PyCFunction) _wrap_PyEigenMatrix6d_cols, METH_NOARGS, NULL },
    {(char *) "Identity", (PyCFunction) _wrap_PyEigenMatrix6d_Identity, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenMatrix6d_norm, METH_NOARGS, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenMatrix6d_Zero, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenMatrix6d_squaredNorm, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenMatrix6d_normalized, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenMatrix6d__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenMatrix6d__tp_dealloc(PyEigenMatrix6d *self)
{
        Eigen::Matrix6d *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenMatrix6d__tp_str(PyEigenMatrix6d *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenMatrix6d__tp_richcompare (PyEigenMatrix6d *PYBINDGEN_UNUSED(self), PyEigenMatrix6d *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenMatrix6d_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Eigen__Matrix6d(Eigen::Matrix6d *cvalue)
{
    PyObject *py_retval;
    PyEigenMatrix6d *py_Matrix6d;

    py_Matrix6d = PyObject_New(PyEigenMatrix6d, &PyEigenMatrix6d_Type);
    py_Matrix6d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix6d->obj = new Eigen::Matrix6d(*cvalue);
    py_retval = Py_BuildValue((char *) "N", py_Matrix6d);
    return py_retval;
}


int _wrap_convert_py2c__Eigen__Matrix6d(PyObject *value, Eigen::Matrix6d *address)
{
    PyObject *py_retval;
    PyEigenMatrix6d *tmp_Matrix6d;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenMatrix6d_Type, &tmp_Matrix6d)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Matrix6d->obj;
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
EigenMatrix6d__nb_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix6d left;
        Eigen::Matrix6d right;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix6d(py_right, &right)) {
            Eigen::Matrix6d result = (left + right);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix6d__nb_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix6d left;
        Eigen::Matrix6d right;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix6d(py_right, &right)) {
            Eigen::Matrix6d result = (left - right);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix6d__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        double left;
        Eigen::Matrix6d right;
        if (_wrap_convert_py2c__double(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix6d(py_right, &right)) {
            Eigen::Matrix6d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix6d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Matrix6d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix6d left;
        Eigen::Matrix6d right;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix6d(py_right, &right)) {
            Eigen::Matrix6d result = (left * right);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    {
        Eigen::Matrix6d left;
        Eigen::Vector6d right;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_left, &left) && _wrap_convert_py2c__Eigen__Vector6d(py_right, &right)) {
            Eigen::Vector6d result = (left * right);
            return _wrap_convert_c2py__Eigen__Vector6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix6d__nb_divide (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix6d left;
        double right;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_left, &left) && _wrap_convert_py2c__double(py_right, &right)) {
            Eigen::Matrix6d result = (left / right);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix6d__nb_inplace_add (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix6d left;
        Eigen::Matrix6d right;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix6d(py_right, &right)) {
            Eigen::Matrix6d result = (left += right);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix6d__nb_inplace_subtract (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix6d left;
        Eigen::Matrix6d right;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix6d(py_right, &right)) {
            Eigen::Matrix6d result = (left -= right);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix6d__nb_inplace_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Matrix6d left;
        Eigen::Matrix6d right;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_left, &left) && _wrap_convert_py2c__Eigen__Matrix6d(py_right, &right)) {
            Eigen::Matrix6d result = (left *= right);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyObject*
EigenMatrix6d__nb_negative (PyObject *py_self)
{
    {
        Eigen::Matrix6d self;
        if (_wrap_convert_py2c__Eigen__Matrix6d(py_self, &self)) {
            Eigen::Matrix6d result = -(self);
            return _wrap_convert_c2py__Eigen__Matrix6d(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods EigenMatrix6d__py_number_methods = {
    (binaryfunc) EigenMatrix6d__nb_add,
    (binaryfunc) EigenMatrix6d__nb_subtract,
    (binaryfunc) EigenMatrix6d__nb_multiply,
    (binaryfunc) EigenMatrix6d__nb_divide,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) EigenMatrix6d__nb_negative,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) EigenMatrix6d__nb_inplace_add,
    (binaryfunc) EigenMatrix6d__nb_inplace_subtract,
    (binaryfunc) EigenMatrix6d__nb_inplace_multiply,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};


static Py_ssize_t
EigenMatrix6d__sq_length (PyEigenMatrix6d *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenMatrix6d___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenMatrix6d__sq_item (PyEigenMatrix6d *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenMatrix6d___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenMatrix6d__sq_ass_item (PyEigenMatrix6d *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenMatrix6d___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenMatrix6d__py_sequence_methods = {
    (lenfunc) EigenMatrix6d__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenMatrix6d__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenMatrix6d__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenMatrix6d_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.Matrix6d",            /* tp_name */
    sizeof(PyEigenMatrix6d),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenMatrix6d__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&EigenMatrix6d__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)&EigenMatrix6d__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenMatrix6d__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenMatrix6d__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenMatrix6d_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenMatrix6d__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenMatrixXd__tp_init__0(PyEigenMatrixXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::MatrixXd();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenMatrixXd__tp_init__1(PyEigenMatrixXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenMatrixXd *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenMatrixXd_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::MatrixXd(*((PyEigenMatrixXd *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenMatrixXd__tp_init__2(PyEigenMatrixXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    int rows;
    int cols;
    const char *keywords[] = {"rows", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &rows, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::MatrixXd(rows, cols);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenMatrixXd__tp_init(PyEigenMatrixXd *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyEigenMatrixXd__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrixXd__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyEigenMatrixXd__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenMatrixXd_normalize(PyEigenMatrixXd *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd_rows(PyEigenMatrixXd *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd___getitem__(PyEigenMatrixXd *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}



PyObject *
_wrap_PyEigenMatrixXd_coeff__0(PyEigenMatrixXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenMatrixXd_coeff__1(PyEigenMatrixXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenMatrixXd_coeff(PyEigenMatrixXd *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenMatrixXd_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenMatrixXd_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenMatrixXd_Random(PyEigenMatrixXd *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int rows;
    int cols;
    const char *keywords[] = {"rows", "cols", NULL};
    PyEigenMatrixXd *py_MatrixXd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &rows, &cols)) {
        return NULL;
    }
    Eigen::MatrixXd retval = Eigen::MatrixXd::Random(rows, cols);
    py_MatrixXd = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_MatrixXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_MatrixXd->obj = new Eigen::MatrixXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_MatrixXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd_transpose(PyEigenMatrixXd *self)
{
    PyObject *py_retval;
    PyEigenMatrixXd *py_MatrixXd;

    Eigen::MatrixXd retval = self->obj->transpose();
    py_MatrixXd = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_MatrixXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_MatrixXd->obj = new Eigen::MatrixXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_MatrixXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd_cols(PyEigenMatrixXd *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd___setitem__(PyEigenMatrixXd *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd_Identity(PyEigenMatrixXd *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int rows;
    int cols;
    const char *keywords[] = {"rows", "cols", NULL};
    PyEigenMatrixXd *py_MatrixXd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &rows, &cols)) {
        return NULL;
    }
    Eigen::MatrixXd retval = Eigen::MatrixXd::Identity(rows, cols);
    py_MatrixXd = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_MatrixXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_MatrixXd->obj = new Eigen::MatrixXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_MatrixXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd_norm(PyEigenMatrixXd *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd_Zero(PyEigenMatrixXd *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int rows;
    int cols;
    const char *keywords[] = {"rows", "cols", NULL};
    PyEigenMatrixXd *py_MatrixXd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &rows, &cols)) {
        return NULL;
    }
    Eigen::MatrixXd retval = Eigen::MatrixXd::Zero(rows, cols);
    py_MatrixXd = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_MatrixXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_MatrixXd->obj = new Eigen::MatrixXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_MatrixXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd_squaredNorm(PyEigenMatrixXd *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd___len__(PyEigenMatrixXd *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenMatrixXd_normalized(PyEigenMatrixXd *self)
{
    PyObject *py_retval;
    PyEigenMatrixXd *py_MatrixXd;

    Eigen::MatrixXd retval = self->obj->normalized();
    py_MatrixXd = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_MatrixXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_MatrixXd->obj = new Eigen::MatrixXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_MatrixXd);
    return py_retval;
}


static PyObject*
_wrap_PyEigenMatrixXd__copy__(PyEigenMatrixXd *self)
{

    PyEigenMatrixXd *py_copy;
    py_copy = PyObject_New(PyEigenMatrixXd, &PyEigenMatrixXd_Type);
    py_copy->obj = new Eigen::MatrixXd(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenMatrixXd_methods[] = {
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenMatrixXd_normalize, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenMatrixXd_rows, METH_NOARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenMatrixXd_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenMatrixXd_Random, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "transpose", (PyCFunction) _wrap_PyEigenMatrixXd_transpose, METH_NOARGS, NULL },
    {(char *) "cols", (PyCFunction) _wrap_PyEigenMatrixXd_cols, METH_NOARGS, NULL },
    {(char *) "Identity", (PyCFunction) _wrap_PyEigenMatrixXd_Identity, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenMatrixXd_norm, METH_NOARGS, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenMatrixXd_Zero, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenMatrixXd_squaredNorm, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenMatrixXd_normalized, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenMatrixXd__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenMatrixXd__tp_dealloc(PyEigenMatrixXd *self)
{
        Eigen::MatrixXd *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenMatrixXd__tp_str(PyEigenMatrixXd *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenMatrixXd__tp_richcompare (PyEigenMatrixXd *PYBINDGEN_UNUSED(self), PyEigenMatrixXd *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenMatrixXd_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


int _wrap_convert_py2c__Eigen__MatrixXd(PyObject *value, Eigen::MatrixXd *address)
{
    PyObject *py_retval;
    PyEigenMatrixXd *tmp_MatrixXd;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenMatrixXd_Type, &tmp_MatrixXd)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_MatrixXd->obj;
    Py_DECREF(py_retval);
    return 1;
}


static Py_ssize_t
EigenMatrixXd__sq_length (PyEigenMatrixXd *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenMatrixXd___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenMatrixXd__sq_item (PyEigenMatrixXd *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenMatrixXd___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenMatrixXd__sq_ass_item (PyEigenMatrixXd *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenMatrixXd___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenMatrixXd__py_sequence_methods = {
    (lenfunc) EigenMatrixXd__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenMatrixXd__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenMatrixXd__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenMatrixXd_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.MatrixXd",            /* tp_name */
    sizeof(PyEigenMatrixXd),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenMatrixXd__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)&EigenMatrixXd__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenMatrixXd__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenMatrixXd__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenMatrixXd_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenMatrixXd__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenVectorXd__tp_init__0(PyEigenVectorXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::VectorXd();
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVectorXd__tp_init__1(PyEigenVectorXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenVectorXd *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVectorXd_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::VectorXd(*((PyEigenVectorXd *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenVectorXd__tp_init__2(PyEigenVectorXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    int rows;
    const char *keywords[] = {"rows", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &rows)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = new Eigen::VectorXd(rows);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenVectorXd__tp_init(PyEigenVectorXd *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[3] = {0,};
    retval = _wrap_PyEigenVectorXd__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVectorXd__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyEigenVectorXd__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    error_list = PyList_New(3);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenVectorXd_normalize(PyEigenVectorXd *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenVectorXd_rows(PyEigenVectorXd *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->rows();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVectorXd___getitem__(PyEigenVectorXd *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    int id;
    const char *keywords[] = {"id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &id)) {
        return NULL;
    }
    retval = self->obj->getItem(id);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}



PyObject *
_wrap_PyEigenVectorXd_coeff__0(PyEigenVectorXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    double retval;
    int row;
    int cols;
    const char *keywords[] = {"row", "cols", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "ii", (char **) keywords, &row, &cols)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->getItem(row, cols);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}

PyObject *
_wrap_PyEigenVectorXd_coeff__1(PyEigenVectorXd *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    int row;
    int cols;
    double val;
    const char *keywords[] = {"row", "cols", "val", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "iid", (char **) keywords, &row, &cols, &val)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    self->obj->setItem(row, cols, val);
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}

PyObject * _wrap_PyEigenVectorXd_coeff(PyEigenVectorXd *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenVectorXd_coeff__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenVectorXd_coeff__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenVectorXd_Random(PyEigenVectorXd *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int rows;
    const char *keywords[] = {"rows", NULL};
    PyEigenVectorXd *py_VectorXd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &rows)) {
        return NULL;
    }
    Eigen::VectorXd retval = Eigen::VectorXd::Random(rows);
    py_VectorXd = PyObject_New(PyEigenVectorXd, &PyEigenVectorXd_Type);
    py_VectorXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_VectorXd->obj = new Eigen::VectorXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_VectorXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenVectorXd_cols(PyEigenVectorXd *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->cols();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVectorXd___setitem__(PyEigenVectorXd *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int retval;
    int row;
    double id;
    const char *keywords[] = {"row", "id", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "id", (char **) keywords, &row, &id)) {
        return NULL;
    }
    retval = self->obj->setItem(row, id);
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVectorXd_norm(PyEigenVectorXd *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->norm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVectorXd_Zero(PyEigenVectorXd *PYBINDGEN_UNUSED(dummy), PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    int rows;
    const char *keywords[] = {"rows", NULL};
    PyEigenVectorXd *py_VectorXd;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "i", (char **) keywords, &rows)) {
        return NULL;
    }
    Eigen::VectorXd retval = Eigen::VectorXd::Zero(rows);
    py_VectorXd = PyObject_New(PyEigenVectorXd, &PyEigenVectorXd_Type);
    py_VectorXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_VectorXd->obj = new Eigen::VectorXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_VectorXd);
    return py_retval;
}


PyObject *
_wrap_PyEigenVectorXd_squaredNorm(PyEigenVectorXd *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVectorXd___len__(PyEigenVectorXd *self)
{
    PyObject *py_retval;
    int retval;

    retval = self->obj->size();
    py_retval = Py_BuildValue((char *) "i", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenVectorXd_normalized(PyEigenVectorXd *self)
{
    PyObject *py_retval;
    PyEigenVectorXd *py_VectorXd;

    Eigen::VectorXd retval = self->obj->normalized();
    py_VectorXd = PyObject_New(PyEigenVectorXd, &PyEigenVectorXd_Type);
    py_VectorXd->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_VectorXd->obj = new Eigen::VectorXd(retval);
    py_retval = Py_BuildValue((char *) "N", py_VectorXd);
    return py_retval;
}


static PyObject*
_wrap_PyEigenVectorXd__copy__(PyEigenVectorXd *self)
{

    PyEigenVectorXd *py_copy;
    py_copy = PyObject_New(PyEigenVectorXd, &PyEigenVectorXd_Type);
    py_copy->obj = new Eigen::VectorXd(*self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenVectorXd_methods[] = {
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenVectorXd_normalize, METH_NOARGS, NULL },
    {(char *) "rows", (PyCFunction) _wrap_PyEigenVectorXd_rows, METH_NOARGS, NULL },
    {(char *) "coeff", (PyCFunction) _wrap_PyEigenVectorXd_coeff, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "Random", (PyCFunction) _wrap_PyEigenVectorXd_Random, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "cols", (PyCFunction) _wrap_PyEigenVectorXd_cols, METH_NOARGS, NULL },
    {(char *) "norm", (PyCFunction) _wrap_PyEigenVectorXd_norm, METH_NOARGS, NULL },
    {(char *) "Zero", (PyCFunction) _wrap_PyEigenVectorXd_Zero, METH_KEYWORDS|METH_VARARGS|METH_STATIC, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenVectorXd_squaredNorm, METH_NOARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenVectorXd_normalized, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenVectorXd__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenVectorXd__tp_dealloc(PyEigenVectorXd *self)
{
        Eigen::VectorXd *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            delete tmp;
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenVectorXd__tp_str(PyEigenVectorXd *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenVectorXd__tp_richcompare (PyEigenVectorXd *PYBINDGEN_UNUSED(self), PyEigenVectorXd *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenVectorXd_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


int _wrap_convert_py2c__Eigen__VectorXd(PyObject *value, Eigen::VectorXd *address)
{
    PyObject *py_retval;
    PyEigenVectorXd *tmp_VectorXd;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenVectorXd_Type, &tmp_VectorXd)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_VectorXd->obj;
    Py_DECREF(py_retval);
    return 1;
}


static Py_ssize_t
EigenVectorXd__sq_length (PyEigenVectorXd *py_self)
{
    PyObject *py_result;
    Py_ssize_t result;

    py_result = _wrap_PyEigenVectorXd___len__(py_self);
    if (py_result == NULL) {
        return -1;
    }
    result = PyInt_AsSsize_t(py_result);
    Py_DECREF(py_result);
    return result;
}



static PyObject*
EigenVectorXd__sq_item (PyEigenVectorXd *py_self, Py_ssize_t py_i)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(i)", py_i);
    result = _wrap_PyEigenVectorXd___getitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (PyErr_ExceptionMatches(PyExc_IndexError) ||
        PyErr_ExceptionMatches(PyExc_StopIteration)) {
        Py_XDECREF(result);
        return NULL;
    } else {
        return result;
    }
}




static int
EigenVectorXd__sq_ass_item (PyEigenVectorXd *py_self, Py_ssize_t py_i, PyObject *py_val)
{
    PyObject *result;
    PyObject *args;

    args = Py_BuildValue("(iO)", py_i, py_val);
    result = _wrap_PyEigenVectorXd___setitem__(py_self, args, NULL);
    Py_DECREF(args);
    if (result == NULL) {
        return -1;
    } else {
        Py_DECREF(result);
        return 0;
    }
}



static PySequenceMethods EigenVectorXd__py_sequence_methods = {
    (lenfunc) EigenVectorXd__sq_length,
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
    (ssizeargfunc) EigenVectorXd__sq_item,
    (ssizessizeargfunc) NULL,
    (ssizeobjargproc) EigenVectorXd__sq_ass_item,
    (ssizessizeobjargproc) NULL,
    (objobjproc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (ssizeargfunc) NULL,
};


PyTypeObject PyEigenVectorXd_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.VectorXd",            /* tp_name */
    sizeof(PyEigenVectorXd),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenVectorXd__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)NULL,     /* tp_as_number */
    (PySequenceMethods*)&EigenVectorXd__py_sequence_methods, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenVectorXd__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenVectorXd__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenVectorXd_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenVectorXd__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};





static int
_wrap_PyEigenQuaterniond__tp_init__0(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenQuaterniond *ctor_arg;
    const char *keywords[] = {"ctor_arg", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenQuaterniond_Type, &ctor_arg)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    std::allocator<Eigen::Quaterniond> alloc;
    self->obj = alloc.allocate(1);
    alloc.construct(self->obj, *((PyEigenQuaterniond *) ctor_arg)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenQuaterniond__tp_init__1(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    const char *keywords[] = {NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "", (char **) keywords)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    std::allocator<Eigen::Quaterniond> alloc;
    self->obj = alloc.allocate(1);
    alloc.construct(self->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenQuaterniond__tp_init__2(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenVector4d *vec;
    const char *keywords[] = {"vec", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenVector4d_Type, &vec)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    std::allocator<Eigen::Quaterniond> alloc;
    self->obj = alloc.allocate(1);
    alloc.construct(self->obj, *((PyEigenVector4d *) vec)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenQuaterniond__tp_init__3(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    double w;
    double x;
    double y;
    double z;
    const char *keywords[] = {"w", "x", "y", "z", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dddd", (char **) keywords, &w, &x, &y, &z)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    std::allocator<Eigen::Quaterniond> alloc;
    self->obj = alloc.allocate(1);
    alloc.construct(self->obj, w, x, y, z);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenQuaterniond__tp_init__4(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    double angle;
    PyEigenVector3d *axis;
    const char *keywords[] = {"angle", "axis", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dO!", (char **) keywords, &angle, &PyEigenVector3d_Type, &axis)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = ::createFromAngleAxis(angle, *((PyEigenVector3d *) axis)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

static int
_wrap_PyEigenQuaterniond__tp_init__5(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyEigenMatrix3d *axis;
    const char *keywords[] = {"axis", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenMatrix3d_Type, &axis)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return -1;
    }
    self->obj = ::createFromMatrix(*((PyEigenMatrix3d *) axis)->obj);
    self->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return 0;
}

int _wrap_PyEigenQuaterniond__tp_init(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs)
{
    int retval;
    PyObject *error_list;
    PyObject *exceptions[6] = {0,};
    retval = _wrap_PyEigenQuaterniond__tp_init__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenQuaterniond__tp_init__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    retval = _wrap_PyEigenQuaterniond__tp_init__2(self, args, kwargs, &exceptions[2]);
    if (!exceptions[2]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        return retval;
    }
    retval = _wrap_PyEigenQuaterniond__tp_init__3(self, args, kwargs, &exceptions[3]);
    if (!exceptions[3]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        return retval;
    }
    retval = _wrap_PyEigenQuaterniond__tp_init__4(self, args, kwargs, &exceptions[4]);
    if (!exceptions[4]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        return retval;
    }
    retval = _wrap_PyEigenQuaterniond__tp_init__5(self, args, kwargs, &exceptions[5]);
    if (!exceptions[5]) {
        Py_DECREF(exceptions[0]);
        Py_DECREF(exceptions[1]);
        Py_DECREF(exceptions[2]);
        Py_DECREF(exceptions[3]);
        Py_DECREF(exceptions[4]);
        return retval;
    }
    error_list = PyList_New(6);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyList_SET_ITEM(error_list, 2, PyObject_Str(exceptions[2]));
    Py_DECREF(exceptions[2]);
    PyList_SET_ITEM(error_list, 3, PyObject_Str(exceptions[3]));
    Py_DECREF(exceptions[3]);
    PyList_SET_ITEM(error_list, 4, PyObject_Str(exceptions[4]));
    Py_DECREF(exceptions[4]);
    PyList_SET_ITEM(error_list, 5, PyObject_Str(exceptions[5]));
    Py_DECREF(exceptions[5]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return -1;
}


PyObject *
_wrap_PyEigenQuaterniond_normalize(PyEigenQuaterniond *self)
{
    PyObject *py_retval;

    self->obj->normalize();
    Py_INCREF(Py_None);
    py_retval = Py_None;
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_slerp(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double t;
    PyEigenQuaterniond *other;
    const char *keywords[] = {"t", "other", NULL};
    PyEigenQuaterniond *py_Quaterniond;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "dO!", (char **) keywords, &t, &PyEigenQuaterniond_Type, &other)) {
        return NULL;
    }
    Eigen::Quaterniond retval = self->obj->slerp(t, *((PyEigenQuaterniond *) other)->obj);
    py_Quaterniond = PyObject_New(PyEigenQuaterniond, &PyEigenQuaterniond_Type);
    py_Quaterniond->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    std::allocator<Eigen::Quaterniond> alloc;
    py_Quaterniond->obj = alloc.allocate(1);
    alloc.construct(py_Quaterniond->obj, retval);
    py_retval = Py_BuildValue((char *) "N", py_Quaterniond);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_inverse(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    PyEigenQuaterniond *py_Quaterniond;

    Eigen::Quaterniond retval = self->obj->inverse();
    py_Quaterniond = PyObject_New(PyEigenQuaterniond, &PyEigenQuaterniond_Type);
    py_Quaterniond->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    std::allocator<Eigen::Quaterniond> alloc;
    py_Quaterniond->obj = alloc.allocate(1);
    alloc.construct(py_Quaterniond->obj, retval);
    py_retval = Py_BuildValue((char *) "N", py_Quaterniond);
    return py_retval;
}



PyObject *
_wrap_PyEigenQuaterniond_isApprox__0(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyEigenQuaterniond *other;
    const char *keywords[] = {"other", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenQuaterniond_Type, &other)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->isApprox(*((PyEigenQuaterniond *) other)->obj);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject *
_wrap_PyEigenQuaterniond_isApprox__1(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs, PyObject **return_exception)
{
    PyObject *py_retval;
    bool retval;
    PyEigenQuaterniond *other;
    double prec;
    const char *keywords[] = {"other", "prec", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!d", (char **) keywords, &PyEigenQuaterniond_Type, &other, &prec)) {
        {
            PyObject *exc_type, *traceback;
            PyErr_Fetch(&exc_type, return_exception, &traceback);
            Py_XDECREF(exc_type);
            Py_XDECREF(traceback);
        }
        return NULL;
    }
    retval = self->obj->isApprox(*((PyEigenQuaterniond *) other)->obj, prec);
    py_retval = Py_BuildValue((char *) "N", PyBool_FromLong(retval));
    return py_retval;
}

PyObject * _wrap_PyEigenQuaterniond_isApprox(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs)
{
    PyObject * retval;
    PyObject *error_list;
    PyObject *exceptions[2] = {0,};
    retval = _wrap_PyEigenQuaterniond_isApprox__0(self, args, kwargs, &exceptions[0]);
    if (!exceptions[0]) {
        return retval;
    }
    retval = _wrap_PyEigenQuaterniond_isApprox__1(self, args, kwargs, &exceptions[1]);
    if (!exceptions[1]) {
        Py_DECREF(exceptions[0]);
        return retval;
    }
    error_list = PyList_New(2);
    PyList_SET_ITEM(error_list, 0, PyObject_Str(exceptions[0]));
    Py_DECREF(exceptions[0]);
    PyList_SET_ITEM(error_list, 1, PyObject_Str(exceptions[1]));
    Py_DECREF(exceptions[1]);
    PyErr_SetObject(PyExc_TypeError, error_list);
    Py_DECREF(error_list);
    return NULL;
}


PyObject *
_wrap_PyEigenQuaterniond_matrix(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    PyEigenMatrix3d *py_Matrix3d;

    Eigen::Matrix3d retval = self->obj->matrix();
    py_Matrix3d = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_Matrix3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix3d->obj = new Eigen::Matrix3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_Identity(void)
{
    PyObject *py_retval;
    PyEigenQuaterniond *py_Quaterniond;

    Eigen::Quaterniond retval = Eigen::Quaterniond::Identity();
    py_Quaterniond = PyObject_New(PyEigenQuaterniond, &PyEigenQuaterniond_Type);
    py_Quaterniond->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    std::allocator<Eigen::Quaterniond> alloc;
    py_Quaterniond->obj = alloc.allocate(1);
    alloc.construct(py_Quaterniond->obj, retval);
    py_retval = Py_BuildValue((char *) "N", py_Quaterniond);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_angularDistance(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyEigenQuaterniond *other;
    const char *keywords[] = {"other", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenQuaterniond_Type, &other)) {
        return NULL;
    }
    retval = self->obj->angularDistance(*((PyEigenQuaterniond *) other)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_toRotationMatrix(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    PyEigenMatrix3d *py_Matrix3d;

    Eigen::Matrix3d retval = self->obj->toRotationMatrix();
    py_Matrix3d = PyObject_New(PyEigenMatrix3d, &PyEigenMatrix3d_Type);
    py_Matrix3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Matrix3d->obj = new Eigen::Matrix3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Matrix3d);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_y(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->y();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_setFromTwoVectors(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    PyEigenVector3d *v1;
    PyEigenVector3d *v2;
    const char *keywords[] = {"v1", "v2", NULL};
    PyEigenQuaterniond *py_Quaterniond;

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!O!", (char **) keywords, &PyEigenVector3d_Type, &v1, &PyEigenVector3d_Type, &v2)) {
        return NULL;
    }
    Eigen::Quaterniond retval = self->obj->setFromTwoVectors(*((PyEigenVector3d *) v1)->obj, *((PyEigenVector3d *) v2)->obj);
    py_Quaterniond = PyObject_New(PyEigenQuaterniond, &PyEigenQuaterniond_Type);
    py_Quaterniond->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    std::allocator<Eigen::Quaterniond> alloc;
    py_Quaterniond->obj = alloc.allocate(1);
    alloc.construct(py_Quaterniond->obj, retval);
    py_retval = Py_BuildValue((char *) "N", py_Quaterniond);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_normalized(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    PyEigenQuaterniond *py_Quaterniond;

    Eigen::Quaterniond retval = self->obj->normalized();
    py_Quaterniond = PyObject_New(PyEigenQuaterniond, &PyEigenQuaterniond_Type);
    py_Quaterniond->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    std::allocator<Eigen::Quaterniond> alloc;
    py_Quaterniond->obj = alloc.allocate(1);
    alloc.construct(py_Quaterniond->obj, retval);
    py_retval = Py_BuildValue((char *) "N", py_Quaterniond);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_w(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->w();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_conjugate(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    PyEigenQuaterniond *py_Quaterniond;

    Eigen::Quaterniond retval = self->obj->conjugate();
    py_Quaterniond = PyObject_New(PyEigenQuaterniond, &PyEigenQuaterniond_Type);
    py_Quaterniond->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    std::allocator<Eigen::Quaterniond> alloc;
    py_Quaterniond->obj = alloc.allocate(1);
    alloc.construct(py_Quaterniond->obj, retval);
    py_retval = Py_BuildValue((char *) "N", py_Quaterniond);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_coeffs(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    PyEigenVector4d *py_Vector4d;

    Eigen::Vector4d retval = self->obj->coeffs();
    py_Vector4d = PyObject_New(PyEigenVector4d, &PyEigenVector4d_Type);
    py_Vector4d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector4d->obj = new Eigen::Vector4d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector4d);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_x(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->x();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_squaredNorm(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->squaredNorm();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_z(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    double retval;

    retval = self->obj->z();
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_setIdentity(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    PyEigenQuaterniond *py_Quaterniond;

    Eigen::Quaterniond retval = self->obj->setIdentity();
    py_Quaterniond = PyObject_New(PyEigenQuaterniond, &PyEigenQuaterniond_Type);
    py_Quaterniond->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    std::allocator<Eigen::Quaterniond> alloc;
    py_Quaterniond->obj = alloc.allocate(1);
    alloc.construct(py_Quaterniond->obj, retval);
    py_retval = Py_BuildValue((char *) "N", py_Quaterniond);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_dot(PyEigenQuaterniond *self, PyObject *args, PyObject *kwargs)
{
    PyObject *py_retval;
    double retval;
    PyEigenQuaterniond *other;
    const char *keywords[] = {"other", NULL};

    if (!PyArg_ParseTupleAndKeywords(args, kwargs, (char *) "O!", (char **) keywords, &PyEigenQuaterniond_Type, &other)) {
        return NULL;
    }
    retval = self->obj->dot(*((PyEigenQuaterniond *) other)->obj);
    py_retval = Py_BuildValue((char *) "d", retval);
    return py_retval;
}


PyObject *
_wrap_PyEigenQuaterniond_vec(PyEigenQuaterniond *self)
{
    PyObject *py_retval;
    PyEigenVector3d *py_Vector3d;

    Eigen::Vector3d retval = self->obj->vec();
    py_Vector3d = PyObject_New(PyEigenVector3d, &PyEigenVector3d_Type);
    py_Vector3d->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    py_Vector3d->obj = new Eigen::Vector3d(retval);
    py_retval = Py_BuildValue((char *) "N", py_Vector3d);
    return py_retval;
}


static PyObject*
_wrap_PyEigenQuaterniond__copy__(PyEigenQuaterniond *self)
{

    PyEigenQuaterniond *py_copy;
    py_copy = PyObject_New(PyEigenQuaterniond, &PyEigenQuaterniond_Type);
    std::allocator<Eigen::Quaterniond> alloc;
    py_copy->obj = alloc.allocate(1);
    alloc.construct(py_copy->obj, *self->obj);
    py_copy->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    return (PyObject*) py_copy;
}

static PyMethodDef PyEigenQuaterniond_methods[] = {
    {(char *) "normalize", (PyCFunction) _wrap_PyEigenQuaterniond_normalize, METH_NOARGS, NULL },
    {(char *) "slerp", (PyCFunction) _wrap_PyEigenQuaterniond_slerp, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "inverse", (PyCFunction) _wrap_PyEigenQuaterniond_inverse, METH_NOARGS, NULL },
    {(char *) "isApprox", (PyCFunction) _wrap_PyEigenQuaterniond_isApprox, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "matrix", (PyCFunction) _wrap_PyEigenQuaterniond_matrix, METH_NOARGS, NULL },
    {(char *) "Identity", (PyCFunction) _wrap_PyEigenQuaterniond_Identity, METH_NOARGS|METH_STATIC, NULL },
    {(char *) "angularDistance", (PyCFunction) _wrap_PyEigenQuaterniond_angularDistance, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "toRotationMatrix", (PyCFunction) _wrap_PyEigenQuaterniond_toRotationMatrix, METH_NOARGS, NULL },
    {(char *) "y", (PyCFunction) _wrap_PyEigenQuaterniond_y, METH_NOARGS, NULL },
    {(char *) "setFromTwoVectors", (PyCFunction) _wrap_PyEigenQuaterniond_setFromTwoVectors, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "normalized", (PyCFunction) _wrap_PyEigenQuaterniond_normalized, METH_NOARGS, NULL },
    {(char *) "w", (PyCFunction) _wrap_PyEigenQuaterniond_w, METH_NOARGS, NULL },
    {(char *) "conjugate", (PyCFunction) _wrap_PyEigenQuaterniond_conjugate, METH_NOARGS, NULL },
    {(char *) "coeffs", (PyCFunction) _wrap_PyEigenQuaterniond_coeffs, METH_NOARGS, NULL },
    {(char *) "x", (PyCFunction) _wrap_PyEigenQuaterniond_x, METH_NOARGS, NULL },
    {(char *) "squaredNorm", (PyCFunction) _wrap_PyEigenQuaterniond_squaredNorm, METH_NOARGS, NULL },
    {(char *) "z", (PyCFunction) _wrap_PyEigenQuaterniond_z, METH_NOARGS, NULL },
    {(char *) "setIdentity", (PyCFunction) _wrap_PyEigenQuaterniond_setIdentity, METH_NOARGS, NULL },
    {(char *) "dot", (PyCFunction) _wrap_PyEigenQuaterniond_dot, METH_KEYWORDS|METH_VARARGS, NULL },
    {(char *) "vec", (PyCFunction) _wrap_PyEigenQuaterniond_vec, METH_NOARGS, NULL },
    {(char *) "__copy__", (PyCFunction) _wrap_PyEigenQuaterniond__copy__, METH_NOARGS, NULL},
    {NULL, NULL, 0, NULL}
};

static void
_wrap_PyEigenQuaterniond__tp_dealloc(PyEigenQuaterniond *self)
{
        Eigen::Quaterniond *tmp = self->obj;
        self->obj = NULL;
        if (!(self->flags&PYBINDGEN_WRAPPER_FLAG_OBJECT_NOT_OWNED)) {
            std::allocator<Eigen::Quaterniond> alloc;
            alloc.deallocate(tmp, 1);
        }
    self->ob_type->tp_free((PyObject*)self);
}



static PyObject *
_wrap_PyEigenQuaterniond__tp_str(PyEigenQuaterniond *self)
{
    std::ostringstream oss;
    oss << *self->obj;
    return PyString_FromString(oss.str ().c_str ());
}


static PyObject*
_wrap_PyEigenQuaterniond__tp_richcompare (PyEigenQuaterniond *PYBINDGEN_UNUSED(self), PyEigenQuaterniond *other, int opid)
{

    if (!PyObject_IsInstance((PyObject*) other, (PyObject*) &PyEigenQuaterniond_Type)) {
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    }
    switch (opid)
    {
    case Py_LT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_LE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_EQ:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_NE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GE:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    case Py_GT:
        Py_INCREF(Py_NotImplemented);
        return Py_NotImplemented;
    } /* closes switch (opid) */
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}


PyObject* _wrap_convert_c2py__Eigen__Quaterniond(Eigen::Quaterniond *cvalue)
{
    PyObject *py_retval;
    PyEigenQuaterniond *py_Quaterniond;

    py_Quaterniond = PyObject_New(PyEigenQuaterniond, &PyEigenQuaterniond_Type);
    py_Quaterniond->flags = PYBINDGEN_WRAPPER_FLAG_NONE;
    std::allocator<Eigen::Quaterniond> alloc;
    py_Quaterniond->obj = alloc.allocate(1);
    alloc.construct(py_Quaterniond->obj, *cvalue);
    py_retval = Py_BuildValue((char *) "N", py_Quaterniond);
    return py_retval;
}


int _wrap_convert_py2c__Eigen__Quaterniond(PyObject *value, Eigen::Quaterniond *address)
{
    PyObject *py_retval;
    PyEigenQuaterniond *tmp_Quaterniond;

    py_retval = Py_BuildValue((char *) "(O)", value);
    if (!PyArg_ParseTuple(py_retval, (char *) "O!", &PyEigenQuaterniond_Type, &tmp_Quaterniond)) {
        Py_DECREF(py_retval);
        return 0;
    }
    *address = *tmp_Quaterniond->obj;
    Py_DECREF(py_retval);
    return 1;
}

static PyObject*
EigenQuaterniond__nb_multiply (PyObject *py_left, PyObject *py_right)
{
    {
        Eigen::Quaterniond left;
        Eigen::Quaterniond right;
        if (_wrap_convert_py2c__Eigen__Quaterniond(py_left, &left) && _wrap_convert_py2c__Eigen__Quaterniond(py_right, &right)) {
            Eigen::Quaterniond result = (left * right);
            return _wrap_convert_c2py__Eigen__Quaterniond(&result);
        }
        PyErr_Clear();
    }
    Py_INCREF(Py_NotImplemented);
    return Py_NotImplemented;
}
static PyNumberMethods EigenQuaterniond__py_number_methods = {
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) EigenQuaterniond__nb_multiply,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (inquiry) NULL,
    (unaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (coercion) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    (unaryfunc) NULL,
    /* Added in release 2.0 */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (ternaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

    /* Added in release 2.2 */
    /* The following require the Py_TPFLAGS_HAVE_CLASS flag */
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,
    (binaryfunc) NULL,

#if PY_VERSION_HEX >= 0x020500F0
    /* Added in release 2.5 */
    (unaryfunc) NULL,

#endif
};

PyTypeObject PyEigenQuaterniond_Type = {
    PyObject_HEAD_INIT(NULL)
    0,                                 /* ob_size */
    (char *) "_eigen3.Quaterniond",            /* tp_name */
    sizeof(PyEigenQuaterniond),                  /* tp_basicsize */
    0,                                 /* tp_itemsize */
    /* methods */
    (destructor)_wrap_PyEigenQuaterniond__tp_dealloc,        /* tp_dealloc */
    (printfunc)0,                      /* tp_print */
    (getattrfunc)NULL,       /* tp_getattr */
    (setattrfunc)NULL,       /* tp_setattr */
    (cmpfunc)NULL,           /* tp_compare */
    (reprfunc)NULL,             /* tp_repr */
    (PyNumberMethods*)&EigenQuaterniond__py_number_methods,     /* tp_as_number */
    (PySequenceMethods*)NULL, /* tp_as_sequence */
    (PyMappingMethods*)NULL,   /* tp_as_mapping */
    (hashfunc)NULL,             /* tp_hash */
    (ternaryfunc)NULL,          /* tp_call */
    (reprfunc)_wrap_PyEigenQuaterniond__tp_str,              /* tp_str */
    (getattrofunc)NULL,     /* tp_getattro */
    (setattrofunc)NULL,     /* tp_setattro */
    (PyBufferProcs*)NULL,  /* tp_as_buffer */
    Py_TPFLAGS_DEFAULT|Py_TPFLAGS_CHECKTYPES,                      /* tp_flags */
    NULL,                        /* Documentation string */
    (traverseproc)NULL,     /* tp_traverse */
    (inquiry)NULL,             /* tp_clear */
    (richcmpfunc)_wrap_PyEigenQuaterniond__tp_richcompare,   /* tp_richcompare */
    0,             /* tp_weaklistoffset */
    (getiterfunc)NULL,          /* tp_iter */
    (iternextfunc)NULL,     /* tp_iternext */
    (struct PyMethodDef*)PyEigenQuaterniond_methods, /* tp_methods */
    (struct PyMemberDef*)0,              /* tp_members */
    0,                     /* tp_getset */
    NULL,                              /* tp_base */
    NULL,                              /* tp_dict */
    (descrgetfunc)NULL,    /* tp_descr_get */
    (descrsetfunc)NULL,    /* tp_descr_set */
    0,                 /* tp_dictoffset */
    (initproc)_wrap_PyEigenQuaterniond__tp_init,             /* tp_init */
    (allocfunc)PyType_GenericAlloc,           /* tp_alloc */
    (newfunc)PyType_GenericNew,               /* tp_new */
    (freefunc)0,             /* tp_free */
    (inquiry)NULL,             /* tp_is_gc */
    NULL,                              /* tp_bases */
    NULL,                              /* tp_mro */
    NULL,                              /* tp_cache */
    NULL,                              /* tp_subclasses */
    NULL,                              /* tp_weaklist */
    (destructor) NULL                  /* tp_del */
};




PyMODINIT_FUNC
#if defined(__GNUC__) && __GNUC__ >= 4
__attribute__ ((visibility("default")))
#endif
init_eigen3(void)
{
    PyObject *m;
    m = Py_InitModule3((char *) "_eigen3", _eigen3_functions, NULL);
    if (m == NULL) {
        return;
    }
    /* Register the 'Eigen::Vector2d' class */
    if (PyType_Ready(&PyEigenVector2d_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Vector2d", (PyObject *) &PyEigenVector2d_Type);
    /* Register the 'Eigen::Matrix2d' class */
    if (PyType_Ready(&PyEigenMatrix2d_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Matrix2d", (PyObject *) &PyEigenMatrix2d_Type);
    /* Register the 'Eigen::Vector3d' class */
    if (PyType_Ready(&PyEigenVector3d_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Vector3d", (PyObject *) &PyEigenVector3d_Type);
    /* Register the 'Eigen::Matrix3d' class */
    if (PyType_Ready(&PyEigenMatrix3d_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Matrix3d", (PyObject *) &PyEigenMatrix3d_Type);
    /* Register the 'Eigen::Vector4d' class */
    if (PyType_Ready(&PyEigenVector4d_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Vector4d", (PyObject *) &PyEigenVector4d_Type);
    /* Register the 'Eigen::Matrix4d' class */
    if (PyType_Ready(&PyEigenMatrix4d_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Matrix4d", (PyObject *) &PyEigenMatrix4d_Type);
    /* Register the 'Eigen::Vector6d' class */
    if (PyType_Ready(&PyEigenVector6d_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Vector6d", (PyObject *) &PyEigenVector6d_Type);
    /* Register the 'Eigen::Matrix6d' class */
    if (PyType_Ready(&PyEigenMatrix6d_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Matrix6d", (PyObject *) &PyEigenMatrix6d_Type);
    /* Register the 'Eigen::MatrixXd' class */
    if (PyType_Ready(&PyEigenMatrixXd_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "MatrixXd", (PyObject *) &PyEigenMatrixXd_Type);
    /* Register the 'Eigen::VectorXd' class */
    if (PyType_Ready(&PyEigenVectorXd_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "VectorXd", (PyObject *) &PyEigenVectorXd_Type);
    /* Register the 'Eigen::Quaterniond' class */
    if (PyType_Ready(&PyEigenQuaterniond_Type)) {
        return;
    }
    PyModule_AddObject(m, (char *) "Quaterniond", (PyObject *) &PyEigenQuaterniond_Type);
}
